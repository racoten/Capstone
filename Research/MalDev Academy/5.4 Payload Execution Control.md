# 5.4 Payload Execution Control

### Introduction

In real-world scenarios, it is important to limit the actions performed by a malware and focus on essential tasks. The more actions performed by the malware, the more likely it'll be picked up by monitoring systems.

[Windows Synchronization Objects](https://learn.microsoft.com/en-us/windows/win32/sync/synchronization-objects) can be utilized to control the execution of a payload. These objects coordinate the access of shared resources by multiple threads or processes, ensuring that shared resources are accessed in a controlled manner and preventing conflicts or race conditions when multiple threads or processes attempt to access the same resource simultaneously. By using synchronization objects, it's possible to control the number of times the payload is executed on a system.

There are several types of synchronization objects, including [semaphores](https://learn.microsoft.com/en-us/windows/win32/sync/semaphore-objects), [mutexes](https://learn.microsoft.com/en-us/windows/win32/sync/mutex-objects), and [events](https://learn.microsoft.com/en-us/windows/win32/sync/event-objects). Each type of synchronization object works in a slightly different manner but ultimately they all serve the same purpose which is to coordinate access of shared resources.

### Semaphores

[Semaphores](https://learn.microsoft.com/en-us/windows/win32/sync/semaphore-objects) are synchronization tools that utilize a value stored in memory to control access to a shared resource. There are two types of semaphores: binary and counting. A binary semaphore has a value of 1 or 0, indicating whether the resource is available or unavailable, respectively. A counting semaphore, on the other hand, has a value greater than 1, representing the number of available resources or the number of processes that can access the resource concurrently.

To control execution of a payload, a named semaphore object will be created each time the payload is executed. If the binary is executed multiple times, the first execution will create the named semaphore and the payload will be executed as intended. On subsequent executions, the semaphore creation will fail as the semaphore with the same name is already running. This indicates that the payload is currently being executed from a previous run and therefore should not be run again to avoid duplication.

[CreateSemaphoreA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea) will be used to create a semaphore object. It is important to create it as a named semaphore to prevent executions after the initial binary run. If the named semaphore is already running, `CreateSemaphoreA` will return a handle to the existing object and `GetLastError` will return `ERROR_ALREADY_EXISTS`. In the code below, if a "ControlString" semaphore is already running, `GetLastError` will return `ERROR_ALREADY_EXISTS`.

```c
HANDLE hSemaphore = CreateSemaphoreA(NULL, 10, 10, "ControlString");

if (hSemaphore != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
	// Payload is already running
else
	// Payload is not running

```

### Mutexes

A [Mutex](https://learn.microsoft.com/en-us/windows/win32/sync/mutex-objects), short for "mutual exclusion", is a synchronization tool used to manage access to shared resources among processes and threads. In practical use, a thread attempting to access a shared resource checks the status of the mutex. If it is locked, the thread waits until the mutex is unlocked before proceeding. If the mutex is not locked, the thread locks it, performs the necessary operations on the shared resource, and then unlocks the mutex upon completion. This ensures that only one thread can access the shared resource at a time, preventing conflicts and data corruption.

[CreateMutexA](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa) is used to created a named mutex as follows:

```c
HANDLE hMutex = CreateMutexA(NULL, FALSE, "ControlString");

if (hMutex != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
	// Payload is already running
else
	// Payload is not running
```

### Events

[Events](https://learn.microsoft.com/en-us/windows/win32/sync/event-objects) are another synchronization tool that can be used to coordinate the execution of threads or processes. They can be either manual or automatic, with manual events requiring explicit set or reset actions and automatic events being triggered by external conditions such as timer expiration or task completion.

To use events in a program, the [CreateEventA](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa) WinAPI can be employed. The usage of the function is demonstrated below:

```c
HANDLE hEvent = CreateEventA(NULL, FALSE, FALSE, "ControlString");

if (hEvent != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
	// Payload is already running
else
	// Payload is not running
```

### Demo

Using Semaphores.

![Image](https://maldevacademy.s3.amazonaws.com/images/Intermediate/control-109459156-0c97cf3a-c176-46da-bd31-afb2d2161b9f.png)

  

Using Mutexes.

![Image](https://maldevacademy.s3.amazonaws.com/images/Intermediate/control-209459157-cda5268b-bd34-47ed-874b-a799e0680fb8.png)

  

Using Events.

![Image](https://maldevacademy.s3.amazonaws.com/images/Intermediate/control-309459160-66750edb-600a-4fef-a1f2-ef2deec92d5e.png)