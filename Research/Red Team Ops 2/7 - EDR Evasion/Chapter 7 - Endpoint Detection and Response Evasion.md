# Endpoint Detection and Response

Endpoint Detection and Response (EDR) is the name given to an integrated security solution which combines real-time monitoring of endpoints (and possibly other log telemetry) with analysis and response capabilities.  Think of an EDR like AV on steroids.  An EDR will primarily:

-   Collect event data from managed endpoints.
-   Analyse the data to identify known threat patterns.
-   Where applicable, automatically respond to threats (such as blocking/containing) and raise alerts.
-   Aid manual investigations by providing forensic and analysis capabilities.

  

Each vendor may architect their solution differently, but the following is a generic high-level view of what an EDR might look like.

  

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/edr_arch.png)

  

The protected endpoints will typically have the EDR's "agent" installed on them.  This is responsible for collecting and shipping log data to a central repository, responding to detected threats, and provides those forensic capabilities.  For instance, a defender may request a file sample from an endpoint, which is collected and returned by the agent.

EDR solutions may also talk back to the vendor's cloud infrastructure, which is useful for deploying software and signature updates.  Some vendors also offer "threat hunting" as a service, where they will hunt for "unknown" malicious activity (activity that is malicious but not detected by the automated analysis) on the customers behalf.

Defenders may interact directly with the EDR's main interface, which is where the policies and alerts are controlled - essentially a single pain of glass to view and manage the overall solution.  Alerts generated by the EDR may also be forwarded to a SIEM.

# Detecting the Bad

EDR agents like to primarily monitor the use of Windows APIs - as we've seen, these are used to perform actions such as process injection and a slew of others that we like to do from our C2.  But how do you monitor which APIs every running process on a machine is using?

A logical place to start is with a driver, since these are designed to have the same privilege level as the kernel itself.  In the past, this allowed AV and EDR vendors to patch kernel code in order to inspect API calls as they transitioned into the kernel from userland.  However, Microsoft introduced Kernel Patch Protection (aka "PatchGuard"), which prevents patching of the kernel.

This forced security vendors to re-evaluate how they perform these inspections.  Most must now carry out their inspection in userland, which is achieved by "API Hooking".  There are multiple ways to do this - we'll look at "inline" and "IAT" hooking.

# IAT Hooking

Let's take the following application.  All it does is call the **MessageBoxW** API, but it serves a good visual example.
```cpp
#include <iostream>
#include <Windows.h>

int main()
{
  return MessageBoxW(NULL, L"This is a test", L"TEST", 0);
}
```

The Import Address Table (IAT) is a relatively simply lookup table within a PE structure - it contains a list of API functions imported by the PE and their associated addresses in memory.  When a PE calls an API, it does not dynamically resolve its address at runtime (e.g. with **GetProcAddress**) because that would be costly.  Instead, it grabs it from the IAT.

If we open the MessageBox app in a tool like [CFF Explorer](https://ntcore.com/?page_id=388), we can view its IAT.

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/iat/iat.png)  

You can also view the IAT of a process whilst it's running in [WinDbg](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools).

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/iat/messagebox-windbg-iat.png)  

When executed, the message box appears with the strings as we intended.

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/messagebox.png)

When the EDR DLL is injected, it will walk the IAT and locate any APIs it wants to hook.  It will then simply replace the addresses of those API with ones that point to detour functions in its own memory space.  This can also be seen in WinDbg.  Here we can see the address is now pointing to **IAT!MessageBoxWDetour** instead of the original in user32.dll.  

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/iat/messagebox-windbg-iat-hooked.png)

When executed with the IAT hook in place, the detour method changes the strings passed to the API call.  The detour method used for this example is very simple:
```c
EXTERN_C
int
WINAPI
HookMessageBoxW(
  _In_opt_ HWND hWnd,
  _In_opt_ LPCWSTR lpText,
  _In_opt_ LPCWSTR lpCaption,
  _In_ UINT uType)
{
  return OrigMessageBoxW(hWnd, L"Hooked baby", L"HOOKED", uType);
}
```

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/messagebox-hooked.png)


# Inline Hooking

At a basic level, inline (or detour/trampoline) hooking is achieved by patching the API call instructions in memory.  When the EDR's userland DLL is injected into a process, it resolves the address of each API function that it wants to hook, and patches a **jmp** instruction at the start for each one.  This will redirect the execution flow to a "detour" method inside the EDR's DLL memory space.  The EDR will inspect the API call and decide what to do with it.

If deemed malicious, the call can just be blocked.  If not, it can be forwarded to the original API function.  It may also raise an alert.

Below is an example of how the MessageBox API appears under normal circumstances in [WinDbg](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools).  We can see that the first instruction is a **sub**.

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/inline/messagebox-windbg.png)

However, when the API is hooked, that instruction is patched with a **jmp**.

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/inline/messagebox-windbg-hooked.png)


# Hook Bypass Strategies

Both IAT and inline hooks can be effectively "unhooked" by patching over them to restore their original values. Since this is all happening in userland of a process we control, we're relatively free to do that.  In the case of inline hooking, we can even reload entire modules from disk (e.g. kernel32.dll, ntdll.dll etc) which would map an entirely fresh copy into memory, erasing the hooks.

One rather significant downside to this, is that EDRs do monitor the integrity of their own hooks.  So even if we did unhook them, the EDR can simply re-hook them at a later date and more significantly, raise an alert that hook tampering was detected.

In my view, a better strategy is to find different ways of executing the desired APIs, without ever touching the hooks.

# Hooking in Action

Jump onto the Attacker Windows VM and open the **CreateRemoteThread** project in Visual Studio.  We're going to insert some simple Console.WriteLine's to print the PID of our injector itself, the handle information to the target process, and the base address returned by VirtualAllocEx.  This will be a useful reference for what's to come.

For instance:
```cs
// Open handle to process
var target = Process.GetProcessesByName("notepad")[0];
Console.WriteLine("Target PID: {0}", target.Id);
Console.WriteLine("Target Handle: 0x{0:X}", target.Handle.ToInt64());
```

Open a **Command Prompt** and set the working directory to `C:\Tools\EDR`.  Run `drvLoader.exe -i` to load the EDR driver and start the ETW tracing session.
```cmd
C:\Tools\EDR>drvLoader.exe -i
Installing driver...
Driver installed!
Starting tracing session...
```

This driver will automatically inject `edr_x64.dll` (the EDR DLL) into every process started from this point.  Start **notepad** (or whatever your target process will be), then run the **CreateRemoteThread** injector.
```c
C:\Users\Administrator>source\repos\ProcessInjection\CreateRemoteThread\bin\Debug\CreateRemoteThread.exe
My PID: 5792
Target PID: 5920
Target Handle: 0x280
Base Address: 0x14B9CBF0000
```

The EDR will hook several injection APIs and logs their use via ETW.  The loader app receives those events and prints them to the console for visibility.  The EDR DLL does not block or modify the API calls, it will simply log them.  Once running, you will see a *lot* of output, but it is possible to identify our "malicious" calls.

EDRs are likely to hook at the lowest level possible.  So instead of hooking OpenProcess in kernel32, they'll hook NtOpenProcess in ntdll.  There are a few good reasons for doing this.  The first is that OpenProcess will itself call NtOpenProcess, and hooking one API is easier than hooking two.  The second is that other (notorious) APIs like MiniDumpWriteDump call NtOpenProcess in the background (to open a handle to LSASS).  This allows the EDR to catch other suspicious activity somewhat indirectly.
```c
[PID: 5792] Arch: x64, CommandLine: 'C:\Users\Administrator\source\repos\ProcessInjection\CreateRemoteThread\bin\Debug\CreateRemoteThread.exe'
[PID: 5792] NtAllocateVirtualMemory(0xFFFFFFFF, 4096, 0x1000, 0x04)
```

Use `Ctrl + C` to cancel the ETW logging and `drvLoader.exe -u` to uninstall the driver.

For brevity, the API call of interest are as follows:
```c
[PID: 5792] NtOpenProcess(5920, 2035711)
[PID: 5792] NtAllocateVirtualMemory(0x280, 263168, 0x3000, 0x04)
[PID: 5792] NtWriteVirtualMemory(0x280, 0x9CBF0000, 263168)
[PID: 5792] NtCreateThreadEx(0x9CBF0000)
```

`[PID: 5792]` is the source of the ETW log - we know our CreateRemoteThread injector had a PID of 5792 from its console output.  In the call to NtOpenProcess, the target PID is 5920 - the PID of the target instance of notepad.  `2035711` is an integer representing the level of privilege being requested for the handle.  In hex, this is **1F0FFF**.  If we cross-reference this with the [OpenProcess](http://pinvoke.net/default.aspx/kernel32/OpenProcess.html) documentation on pinvoke.net, we see this is the value they provide for requesting "All" access.

Next is the call to NtAllocateVirtualMemory.  `0x280` is the handle to notepad returned by NtOpenProcess, and `263168` is the requested size in bytes.  If we go to the team server VM, we can confirm that this is the exact size of the Beacon shellcode.
```bash
# ls -l /root/beacon.bin 
-rw-r--r-- 1 root root 263168 Dec 20 12:23 /root/beacon.bin
```

`0x3000` is the memory allocation type (MEM_COMMIT and MEM_RESERVE), and `0x04` is the memory protection (PAGE_READWRITE).  We know this to be the case from our CreateRemoteThread injector source code.  NtProtectVirtualMemory is not hooked, but if it was, we'd also see the flip to RX.

In the call to NtWriteVirtualMemory we see `0x9CBF0000`, which is the base address returned to our injector by NtAllocateVirtualMemory.  This is confirmed on its console output (minus the `0x14B` prefix).  And again, we see the number of bytes written exactly match the Beacon shellcode size.  The EDR also has access to the full buffer being provided (i.e. the entire shellcode).

Finally, in the call to NtCreateThreadEx, we've logged its start address.  This matches the memory location where the shellcode has been written to.

Hopefully, this has provided some insight into how an EDR can collect information about API calls and correlate them to identify malicious intent.  It's definitely not an exact science, but can be effective.


# Manual Mapping

If you already have code-execution capabilities on a machine running an EDR, can figure out which APIs are hooked by reading our processes memory space.  [Matt Hand](https://twitter.com/matterpreter) came up with a simple (yet elegant) approach which he published in his [HookDetector](https://github.com/matterpreter/OffensiveCSharp/blob/master/HookDetector/Program.cs) project.  It's based on the premise that the instructions for Nt APIs always start the same way:
```assembly
mov r10, rcx
mov eax ...
```

We can find our functions of interest within the instance of ntdll loaded into our process, read the first 4 bytes and compare them to this known pattern.  If they don't match, we can conclude that they're hooked.  Another great "feature" is that this implementation doesn't rely on API that may itself be hooked (such as NtReadVirtualMemory).

Make sure the driver is loaded, then run the tool.  You should get output like this:
```c
NTDLL Base Address: 0x7FFF29370000
    NtClose                   0x7FFF2940ECE0 - SAFE
    NtAllocateVirtualMemory   0x7FFF2940EE00  - HOOK DETECTED
    Instructions:             E9 D3 13 FE BF CC CC CC F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3 CD 2E C3 0F 1F 84 00 00 00 00 00
    NtAllocateVirtualMemoryEx 0x7FFF2940F9B0 - SAFE
    NtCreateThread            0x7FFF2940F4C0 - SAFE
    NtCreateThreadEx          0x7FFF29410370  - HOOK DETECTED
    Instructions:             E9 23 FF FD BF CC CC CC F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3 CD 2E C3 0F 1F 84 00 00 00 00 00
    NtCreateUserProcess       0x7FFF29410470 - SAFE
    NtFreeVirtualMemory       0x7FFF2940EEC0 - SAFE
    NtLoadDriver              0x7FFF29410C10 - SAFE
    NtMapViewOfSection        0x7FFF2940F000 - SAFE
    NtOpenProcess             0x7FFF2940EFC0  - HOOK DETECTED
    Instructions:             E9 B3 11 FE BF CC CC CC F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3 CD 2E C3 0F 1F 84 00 00 00 00 00
    NtProtectVirtualMemory    0x7FFF2940F500 - SAFE
    NtQueueApcThread          0x7FFF2940F3A0 - SAFE
    NtQueueApcThreadEx        0x7FFF29411830 - SAFE
    NtResumeThread            0x7FFF2940F540 - SAFE
    NtSetContextThread        0x7FFF29411D30 - SAFE
    NtSetInformationProcess   0x7FFF2940EE80 - SAFE
    NtSuspendThread           0x7FFF29412350 - SAFE
    NtUnloadDriver            0x7FFF29412490 - SAFE
    NtWriteVirtualMemory      0x7FFF2940F240  - HOOK DETECTED
    Instructions:             E9 F3 0F FE BF CC CC CC F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3 CD 2E C3 0F 1F 84 00 00 00 00 00
```

This shows that **NtAllocateVirtualMemory**, **NtCreateThreadEx,** **NtOpenProcess** and **NtWriteVirtualMemory** are hooked.  We can also see that there are also a lot of APIs that are not hooked.  A perfectly legitimate strategy would be to use a process injection technique that utilises those unhooked APIs, and just avoid the hooked ones altogether.  However, for the purposes of this lesson we're going to explicitly demonstrate how to use these hooked APIs.

## Manual Mapping

Use D/Invoke's **Map.MapModuleToMemory()** method to read and map a new instance of ntdll.dll into the process.  This won't stomp over the existing ntdll in memory, but rather be mapped into a new memory region.
```cs
var ntdll = Map.MapModuleToMemory(@"C:\Windows\System32\ntdll.dll");
```

If you can inspect the memory regions of the process in a debugger, you'll see that the module is allocated in a random piece of memory, not appearing to be backed by a module on disk.

![](https://rto2-assets.s3.eu-west-2.amazonaws.com/edr/ntdll-modulebase.png)

Setup the parameters for calling **NtOpenProcess** and then use **Generic.CallMappedDLLModuleExport()**, passing in the mapped ntdll module, the name of the export, and the desired parameters.
```cs
var oa = new Data.Native.OBJECT_ATTRIBUTES();
var cid = new Data.Native.CLIENT_ID
{
    UniqueProcess = (IntPtr)1234
};

var hProcess = IntPtr.Zero;
var parameters = new object[]
{
    hProcess, Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, oa, cid
};

var status = (Data.Native.NTSTATUS)Generic.CallMappedDLLModuleExport(
    _ntdllMap.PEINFO,
    _ntdllMap.ModuleBase,
    "NtOpenProcess",
    typeof(Native.DELEGATES.NtOpenProcess),
    parameters,
    false);

if (status == Data.Native.NTSTATUS.Success)
    hProcess = (IntPtr)parameters[0];
```

Do this for the remaining APIs and perform the injection as before.  You should not see any of the API calls in the ETW tracing session.

#####  Don't forget to call **Map.FreeModule(ntdll)** to free the mapped instance of ntdll from the process after use.  There's no need to leave it lying around and may serve as an indicator.

One downside is that D/Invoke needs to call some APIs such as **NtAllocateVirtualMemory** and **NtWriteVirtualMemory** in order to map the module into memory.