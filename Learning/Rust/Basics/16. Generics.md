# 16. Generics

## Generic Types

We've seen multiple instances where letters such as `T` and `E` are used to represent a data type, such as `Option<T>` and `Result<T,E>`.  Under the hood, collections such as vectors also use generics, i.e. `Vec<T>`.  This allows you to create a vector containing any data type, even custom data structures that you create.

```rust
fn main() {  
    let people : Vec<Person> = Vec::new();  
}  
  
struct Person {  
      
}
```

This is far more flexible than having specific concrete implementations only for Rust's primitive data types.  When we discussed functions in the **Control Flow** module, we created this function to add to unsigned 8-bit values.

```rust
fn add_integers(i1: u8, i2: u8) -> u8 {  
    i1 + i2  
}
```

One issue with this function is that it can only explicitly accept and return u8.  We can't pass u16 or any other integer type, which means we would have to write multiple functions that effectively do the same thing but for each different integer type.

This is where a generic can come into play - instead of declaring a function with concrete data types, we can make it accept a generic data type.  That could look something like this:

```rust
fn main() {  
    let result = add_integers(1, 2);  
    println!("{}", result);  
}  
  
fn add_integers<T>(i1: T, i2: T) -> T {  
    i1 + i2  
}
```

We first tell the function that it's going to be accepting a generic data type, `T` via the angle brackets `<T>`.  This T can be any type including u8, i8, u16, i16, etc.

In this example, we only need to declare one generic type.  Both `i1` and `i2` are of the same type (i.e. you cannot add a u8 to a u16) and it will return the same data type (u8 + u8 returns a u8; u16 + u16 returns a u16, etc).  You could easily declare multiple generic types by using a different letter to represent them.

For instance, if we wanted this function to return a different data type, we could represent it with the letter U.  The function signature would then look like this:  `fn add_integers<T, U>(i1: T, u2: T) -> U`.

The code above won't actually work because the compiler can't guarantee that the data types being passed into the function can be added.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/df2/1d0/9b8/t-to-t.png)

What if T was a String, array, vector, or custom data structure?  Those cannot simply be added together.  The compiler is actually very useful here and says "consider restricting type parameter `T`".  What this means is to place a "bound" on T to ensure that only data types that can be added can be passed in.

## Bounds

There are two places where bounds can be declared.  The first is inside the angle brackets,  `< >`.

```rust
fn add_integers<T: Add<Output = T>>(i1: T, i2: T) -> T {  
    i1 + i2  
}
```

We're specifying that T needs to support the `Add` trait and that it will also `Output` a data type of T (not all traits need their output explicitly set).

The other method is by using the `where` keyword.

```rust
fn add_integers<T>(i1: T, i2: T) -> T where T: Add<Output = T> {  
    i1 + i2  
}
```

Some people prefer the readability of using `where`, and have them each on their own line if multiple bounds are required.

```rust
use std::ops::Add;  
  
fn main() {  
    let result = add_integers(1, 2);  
    println!("{}", result);  
}  
  
fn add_integers<T>(i1: T, i2: T) -> T  
    where T: Add<Output = T> {  
    i1 + i2  
}
```

The compiler will stop you making some mistakes when it comes to generics, such as passing different data types.  It cannot stop others - for instance, what would happen is we passed two u8 values that when added together come to more than the maximum value?

Well, if the binary is compiled in Debug mode, it will simply cause a runtime panic.  If it's compiled in Release mode, then it will perform a rollover.  This means that it will rollover from it's highest value, 255 back to 0.