# 6. Control Flow

## If / else

We've already seen examples of the `if` statement in a previous module, although it was not explained.

The construct of the statement goes if "condition", followed by the code to execute.  The code inside the curly braces only executes if the condition evaluates to true.  Some languages require the condition to be placed in parenthesis, but Rust does not enforce this.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/84a/88f/a63/if.png)

You can add an additional code block that will execute if the condition is false, rather than true.  This is done with `else`.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/85a/ed8/494/if-else.png)

You can also add additional branches using `else if`.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/2df/485/84f/else-if.png)

Each condition is evaluated from top to bottom.  If one is true, the relevant code will execute and flow will break out and no other conditions will be evaluated.  This allows the final else case to be a kind of "catch all" in the event that every condition evaluates to false.

Multiple logical operators can be combined but this can lead to unexpected results if they're not evaluated in the proper order.  Consider the following example and make a prediction of the outcome.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/834/179/7ba/incorrect.png)

It seems that what we're trying to say is that condition1 OR condition2 needs to be true AND condition3 needs to be true as well.  Since condition3 is set to false, the entire expression should come out as false, right?  But it doesn't.

This is due to the order in which the conditions are evaluated - the AND statement is evaluated first, followed by the OR.

"condition2 && condition3" evaluates to "false" because condition2 and condition3 are both currently set to false.  This would also be the case if one of them was true - because it's an AND operator, both condition2 and condition3 would have to be true for that portion to come out as true overall.

The next part of the expression is then evaluated, which is "condition1 || condition2".  Since condition1 is true, this expression comes out as true and the code inside the braces is executed.

To address this, we need to put parenthesise around the OR expression to force it to be evaluated first.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/0cb/866/5a4/correct.png)

Now it will evaluate "condition1 || condition2", which is true because condition1 is true.  But then true && condition3 comes out as false, because condition3 is false.  So this time, we don't see the "Good to go" message.

## Match

The `match` keyword is a pattern-matching construct which allows you to add cases for certain conditions.  This is generally nicer to use than multiple else if statements.  Take the following example:

![](https://files.cdn.thinkific.com/file_uploads/584845/images/8c4/a26/6c3/animal.png)

This can be condensed down into:

```rust
fn main() {  
    let animal = "Dog";  
  
    match animal {  
        "Dog" => println!("Woof"),  
        "Cat" => println!("Meow"),  
        _ => println!("Unknown")  
    }  
}
```

The comparison is fairly self-explanatory and to my eye, nicer to read.  The `_ =>` is used as a "catch all" in case none of the cases match.

We'll also see how match can be leveraged when dealing with error handling in a later module.

## Enums

An `enum` (or enumeration) is a set of pre-defined constants (i.e. values that cannot be changed).  For example, we could have a "status" enum to indicate whether a person is dead or alive.

```rust
enum Status {  
    Dead,  
    Alive  
}  
  
fn main() {  
    let (first_name, last_name, status) = ("Charles", "Dickens", Status::Dead);  
}
```

Under the hood, enums are referenced by integer values by default rather than strings or anything else.  In this case "Dead" is 0 and "Alive" is 1.  But this isn't actually a hard limitation - an enum can contain any data type and the same enum can even hold multiple data types at the same time.

You can also use enums with match.

```rust
enum Status {  
    Dead,  
    Alive  
}  
  
fn main() {  
    let (first_name, last_name, status) = ("Charles", "Dickens", Status::Dead);  
  
    match status {  
        Status::Alive => println!("{} {} is alive.", first_name, last_name),  
        Status::Dead => println!("{} {} is dead.", first_name, last_name)  
    }  
}
```