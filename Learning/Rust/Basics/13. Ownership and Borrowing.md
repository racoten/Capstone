# 13. Ownership and Borrowing

## Ownership

Ownership and borrowing are probably the hardest of the fundamental Rust concepts to grasp.  Not least because (to my knowledge), no other language behaves in this manner.

Take the following example:

```rust
fn main() {  
    let mut message1 = String::from("Hello, World!");  
    println!("{}", message1);  
  
    let message2 = message1;  
    println!("{}", message2);  
}
```

We're declaring a new mutable string, message1 and printing it to the console.  We then declare a new variable called message2, but assign it the value of message1.  We then print message1 to the console again.

What do you think will happen?  Will it print "Hello, world" twice?  Obviously not :) The compiler throws a "borrow of moved value" error.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/82d/a09/f7b/borrow-error.png)

The reason is as follows:

The message1 variable is stored on the stack, but the String value itself is stored on the heap.  The "content" of message1 is therefore a memory address that points to the correct location on the heap that contains the actual String data.  The important concept to grasp is that message1 is the "data owner".

When we assign the value of message1 to message2, message1 ceases to become the data owner and can no longer reference that heap memory.  The message2 variable has become the new owner for that data.

There may be instances where we genuinely need to reference the same data across multiple variables.  There are some hacky ways to do it, such as copying or cloning the data.  But this doesn't work well if the data then changes.  This is where borrowing comes into play.

## Borrowing

Borrowing allows another variable to reference the data, without deallocating the original variable.  The way this works is by effectively using pointers.  You can get a pointer to data in memory using the ampersand, `&` and even print its address using the pointer formatter, `:p`.

```rust
fn main() {  
    let mut message1 = String::from("Hello, World!");  
    println!("{}", message1);  
  
    let message2 = &message1;  
    println!("message1 lives at {:p}.", message2);  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/6c9/f99/520/address.png)

message2 now contains the memory address of "Hello, world" on the heap, without taking ownership from message1.  We can prove this by printing it again after message2 has been declared.

```rust
fn main() {  
    let mut message1 = String::from("Hello, World!");  
    println!("{}", message1);  
  
    let message2 = &message1;  
    println!("{}", message2);  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/6a1/53b/4bc/hello-world-twice.png)

But things get a little more complex when we want to actually modify the data.

First, we need to tell Rust that message2 is a pointer to a mutable String.  However, if we then try and assign a new value, it will highlight an error.

```rust
fn main() {  
    let mut message1 = String::from("Hello, World!");  
    println!("{}", message1);  
  
    let message2 = &mut message1;  
    message2 = String::from("Hello");  
    println!("{}", message2);  
}
```

This is because message2 is a pointer to the memory address that holds the String, rather than the String itself.  Instead, we need to "dereference" message2 using an asterix, `*`.

```rust
fn main() {  
    let mut message1 = String::from("Hello, World!");  
    println!("{}", message1);  
  
    let message2 = &mut message1;  
    *message2 = String::from("Hello");  
    println!("{}", message2);  
}
```

Now, if we print message1 to the console, it will be "Hello", because we've used two variables to reference and modify the same piece of data.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/200/6c6/73a/final.png)