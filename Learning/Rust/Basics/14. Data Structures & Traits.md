# 14. Data Structures and Traits

## Data Structures

A `struct` in Rust is a means of defining a structure for data that you want to store.  In some previous examples I used a tuple to store information about a person, and a deconstruction to provide user-friendly names.

```rust
fn main() {  
    let tuple = ("Charles", "Dickens", 1812);  
    let (first_name, last_name, dob) = tuple;  
    println!("{} {} was born in {}", first_name, last_name, dob);  
}
```

This isn't super convenient, so instead we can define a data structure, with the `struct` keyword.  Each field is given a name and data type.

```rust
enum Status {  
    ALIVE,  
    DEAD  
}  
  
struct Person {  
    first_name: String,  
    last_name: String,  
    date_of_birth: u16,  
    status: Status  
}
```

A new instance of a person can then be created.

```rust
enum Status {  
    ALIVE,  
    DEAD  
}  
  
struct Person {  
    first_name: String,  
    last_name: String,  
    date_of_birth: u16,  
    status: Status  
}  
  
fn main() {  
    let person = Person {  
        first_name: String::from("Charles"),  
        last_name: String::from("Dickens"),  
        date_of_birth: 1812,  
        status: Status::ALIVE  
    };  
  
    println!("{} {} was born in {}.", person.first_name, person.last_name, person.date_of_birth);  
}
```

Structs can also be used in other structs, such as book and author structs.

```rust
struct Book {  
    title: String,  
    author: Author  
}  
  
struct Author {  
    first_name: String,  
    last_name: String,  
    date_of_birth: u16  
}
```

## Associated Functions

If you're familiar with an object-oriented language like C#, you will know that classes can contain methods which are typically used to access or change the data held within that class instance.  Rust does not do this.  Instead, you create function definitions outside of the data structures, but have something called an association that kind of links them together.

An associated function can either be standalone and called like `Foo::bar();` or if the `self` keyword is passed in as a parameter, it can be called on an instance, like `foo.bar();`

The `impl` keyword is used to define custom implementations on a type - in this case our Person struct.  Inside, we create a new function with a name and ensure that a mutable pointer to itself is passed in as a parameter.  Inside the curly braces is the code to run - we're just setting the status field to `DEAD`.

```rust
impl Person {  
    fn kill(&mut self) {  
        self.status = Status::DEAD;  
    }  
}
```

This now allows us to call the `.kill()` function on an instance of Person.

```rust
enum Status {  
    ALIVE,  
    DEAD  
}  
  
struct Person {  
    first_name: String,  
    last_name: String,  
    date_of_birth: u16,  
    status: Status  
}  
  
impl Person {  
    fn kill(&mut self) {  
        self.status = Status::DEAD;  
    }  
}  
  
fn main() {  
    let mut person = Person {  
        first_name: String::from("Charles"),  
        last_name: String::from("Dickens"),  
        date_of_birth: 1812,  
        status: Status::ALIVE  
    };  
  
    person.kill();  
  
    match person.status {  
        Status::ALIVE => println!("{} {} is alive.", person.first_name, person.last_name),  
        Status::DEAD => println!("{} {} is dead.", person.first_name, person.last_name),  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/c6d/6e6/2da/dead.png)

These functions can also return data - so another example to highlight how this can be useful is to create a struct to define a rectangle, and an associated method to calculate its area.

```rust
struct Rectangle {  
    length: u16,  
    width: u16  
}  
  
impl Rectangle {  
    fn calculate_area(&self) -> u16 {  
        self.length * self.width  
    }  
}  
  
fn main() {  
    let rectangle = Rectangle {  
        length: 20,  
        width: 15,  
    };  
  
    let area = rectangle.calculate_area();  
    println!("Length: {}, Width: {}, Area: {}", rectangle.length, rectangle.width, area);  
}
```

Another use is to create a "new" function, which we can make behave a little like a constructor in C#.  This will take in a length, a width and simply returns a new instance of a Rectangle with those values.

```rust
impl Rectangle {  
    fn new(length: u16, width: u16) -> Self {  
        Self {  
            length,  
            width  
        }  
    }  
  
    fn calculate_area(&self) -> u16 {  
        self.length * self.width  
    }  
}
```

This allows us to create new rectangles in a slightly shorter (and more readable) way.

```rust
struct Rectangle {  
    length: u16,  
    width: u16  
}  
  
impl Rectangle {  
    fn new(length: u16, width: u16) -> Self {  
        Self {  
            length,  
            width  
        }  
    }  
  
    fn calculate_area(&self) -> u16 {  
        self.length * self.width  
    }  
}  
  
fn main() {  
    let rectangle = Rectangle::new(20, 15);  
    let area = rectangle.calculate_area();  
  
    println!("Length: {}, Width: {}, Area: {}", rectangle.length, rectangle.width, area);  
}
```

## Traits

A trait in Rust behaves somewhat like interfaces in other languages - and are a way of enforcing a given type into implementing some functionality.  Here's a struct for a `Sheep` and a trait I've called `AnimalTraits`.  This trait has a single function, `make_noise`.  You can define multiple functions in a trait and even have them return data if desired.

```rust
struct Sheep {  
    name: String  
}  
  
trait AnimalTraits {  
    fn make_noise(&self);  
}
```

If we create a new instance of a Sheep, it will have the make_noise method available on it.

```rust
fn main() {  
    let sheep = Sheep {name: String::from("Babe"),};
	sheep.make_noise(); 
}
```

This code won't run however, because make_noise does not have an implementation (i.e. no code associated with it).  We define this using the `impl` keyword again, along with the `for` keyword.

```rust
struct Sheep {  
    name: String  
}  
  
trait AnimalTraits {  
    fn make_noise(&self);  
}  
  
impl AnimalTraits for Sheep {  
    fn make_noise(&self) {  
        println!("Baaa");  
    }  
}  
```

Running this code will print "Baaaa" to the console.  The same trait can be added to other types, each with their own implementation.  For instance, if we wanted to add a `Dog` type:

```rust
impl AnimalTraits for Dog {  
    fn make_noise(&self) {  
        println!("Woof");  
    }  
}
```

We can now create an instance of a Sheep and a Dog, call make_noise on each, and each will print something different to the console.

```rust
fn main() {  
    let sheep = Sheep {name: String::from("Babe"),};  
    sheep.make_noise();  
  
    let dog = Dog {name: String::from("Sparky"),};  
    dog.make_noise();  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/11c/9c6/c5c/baa-woof.png)

You can also define a trait with a concrete implementation.

```rust
struct Sheep {  
    name: String  
}  
  
struct Dog {  
    name: String  
}  
  
trait AnimalTraits {  
    fn make_noise(&self);  
    fn test_func(&self) {  
        println!("Nothing here...");  
    }  
}  
  
impl AnimalTraits for Sheep {  
    fn make_noise(&self) {  
        println!("Baaa");  
    }  
}  
  
impl AnimalTraits for Dog {  
    fn make_noise(&self) {  
        println!("Woof");  
    }  
}  
  
fn main() {  
    let sheep = Sheep {name: String::from("Babe"),};  
    sheep.make_noise();  
    sheep.test_func();  
  
    let dog = Dog {name: String::from("Sparky"),};  
    dog.make_noise();  
    sheep.test_func();  
}
```

Now any type that implements AnimalTraits will have `test_func` available, which will always execute the same code.