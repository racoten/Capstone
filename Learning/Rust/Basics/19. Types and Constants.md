# 19. Types and Constants

You can also build specific types and constants into your code, which can improve your quality of life in a variety of ways.

In this example, I've declared types for `Handle`, `Win32Error` and `ProcessAccessRights` as `*mut c_void`, `u32`, and `u32` respectively; and a constant for `PROCESS_ALL_ACCESS`.  The `open_process` function has also been modified to accept the ProcessAccessRights type, and return a `Result<Handle, Win32Error>`.

```rust
type Handle = *mut c_void;  
type Win32Error = u32;  
type ProcessAccessRights = u32;  
const PROCESS_ALL_ACCESS: ProcessAccessRights = 0xF01FF;

fn open_process(desiredAccess: ProcessAccessRights, inheritHandle: bool, processId: u32) -> Result<Handle, Win32Error> {  
    let handle = unsafe {  
        OpenProcess(desiredAccess, inheritHandle, processId)  
    };  
  
    if handle == null_mut() {  
        Err(unsafe { GetLastError() })  
    } else {  
        Ok(handle)  
    }  
}
```

Nothing else in the function body has needs to change because the underlying data types haven't changed.

The real benefits come when calling the function.  Having the ProcessAccessRights constants saves us from having to remember or look up the correct values all the time; and having the defined data types (Handle and Win32Error) makes the annotations by the IDE more meaningful.  At a glance we can see the result we're getting is either a Handle or Win32Error, rather than generic *mut c_void and u32 types.

```rust
use std::ptr::null_mut;  
use std::ffi::c_void;  
  
type Handle = *mut c_void;  
type Win32Error = u32;  
type ProcessAccessRights = u32;  
const PROCESS_ALL_ACCESS: ProcessAccessRights = 0xF01FF;  
  
#[link(name = "kernel32")]  
extern {  
    fn GetLastError() -> u32;  
    fn OpenProcess(dwDesiredAccess: ProcessAccessRights, bInheritHandle: bool, dwProcessId: u32) -> Result<Handle, Win32Error>;  
}  
  
fn main () {  
    let result = open_process(PROCESS_ALL_ACCESS, false, 26768);  
    match result {  
        Ok(h) => { println!("hProcess: {:x?}", h)}  
        Err(e) => { println!("OpenProcess failed: {}", e)}  
    }  
}  
  
fn open_process(desiredAccess: ProcessAccessRights, inheritHandle: bool, processId: u32) -> Result<Handle, Win32Error> {  
    let handle = unsafe {  
        OpenProcess(desiredAccess, inheritHandle, processId)  
    };  
  
    if handle == null_mut() {  
        Err(unsafe { GetLastError() })  
    } else {  
        Ok(handle)  
    }  
}
```