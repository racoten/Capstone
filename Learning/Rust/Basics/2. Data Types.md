# 2. Data Types

## Scalar vs Compound

Data types go hand-in-hand with variables, so it's hard to cover them as separate topics.  Some concepts here may not make 100% sense until you complete the **Variables** module, so feel free to revisit this module again if you need to.

Rust has two data type subsets called scalar and compound.  A scalar holds a single value, where a compound can hold multiple values (i.e. they're collections).

Scalar types include integers, chars, and booleans; and compound types include arrays and tuples.

Data types are also referred to as being "primitive".  These are built into Rust's standard library and are stored on the stack.  Rust allows you to created your own custom data structures, which are stored on the heap.

## Integers & Floating Points

An integer is whole number, -2, -1, 0, 1, 2, etc.

If we want an integer to be negative, it should be declared as a "signed" integer.  Otherwise, it can be "unsigned".  Unsigned integers can be larger than signed integers because we're not wasting a "sign" bit.

We can allocate different sizes for an integer in multiples of 8 bits:  8, 16, 32, 64 and 128 bits.  An unsigned 8-bit integer (`u8`) can be 0 to 255; whereas a signed 8-bit integer (`i8`) can be -128 to 127.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/cd5/565/840/integers.png)

A floating point is a number that can have decimal places, 8.2, 3.14, etc.

There are only two types of floating point numbers:  `f32` and `f64`, which are 32 bits and 64 bits in size respectively.  They are also both signed - there are no unsigned floating point types in Rust.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/573/fb4/6f3/floats.png)

## Boolean & Characters

A `bool` is a true or false value.  It's a fundamental type as most "decisions" in a program are made based on a boolean expression (something that evaluates to true or false).

![](https://files.cdn.thinkific.com/file_uploads/584845/images/a72/2e5/4c2/bool.png)

A `char` is a single letter or number, represented by a number.  Those "numbers" are standardised in the [ASCII](https://www.lookuptables.com/text/ascii-table) and [Unicode](https://www.lookuptables.com/text/unicode-characters) tables.  Different languages allow different byte sizes for characters, from 1 to 4 bytes.  Rust uses 4 bytes, which allows it to use any character in UTF-32.

A character is defined with single quotes.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/445/865/f6f/char.png)

## Arrays and Tuples

The array and tuples are both types of collections.  An array can hold multiple values of a single data type; whereas a tuple can hold multiple values but of various data types.

Both types are very fast to use at runtime, but they are fixed size.  To create an array, we can do something like:

![](https://files.cdn.thinkific.com/file_uploads/584845/images/a14/10b/601/array1.png)

Where i32 is the data type and 5 is the number of elements.  We then initialise each value, 1 to 5.

Manually initialising each value is not viable for large arrays.  In this case, we can set every element to the same initial value using the following syntax:

![](https://files.cdn.thinkific.com/file_uploads/584845/images/750/2d4/2d0/array2.png)

This will create an array of 1000 elements and set each value to 0.

Any element in an array can be accessed by its index.  Arrays are "zero-indexed" which means the first element is index 0, the second is index 1 and so on.

The index of an array is accessed using square brackets, e.g. `array[0]`.  To print the 3rd element:
```rust
fn main() {
	let array = [1, 2, 3, 4, 5];
	println!("{}", array[2]);
}
```

A tuple is declared using regular parenthesise for both the data types and initial values; and instead of accessing a tuple index via square braces, we use the period, `.`.
```rust
fn main() {  
    println!("Hello, world!");  
    let tuple = ("Charles", "Dickens", 1812);  
    println!("{} {} was born in {}.", tuple.0, tuple.1, tuple.2);  
}
```

You may also use a concept called "deconstruction" to assign friendly variable names to your elements.
```rust
fn main() {  
    println!("Hello, world!");  
    let tuple = ("Charles", "Dickens", 1812);  
    let (first_name, lastname, dob) = tuple;  
    println!("{} {} was born in {}.", first_name, lastname, dob);  
}
```
## Strings

Rust has two types of strings:  `String` and `&str` (called a string slice).  The main practical difference is that the String is mutable and &str is immutable.  For this reason, String is always stored on the heap, whereas &str may be stored on the stack.  Mutability is covered in the **Variables** module.

A string slice can be declared using double quotes:
```rust
fn main() {  
    let slice = "Charles Dickens";  
}
```

A string slice may be converted to a String using the `.to_string()` or `String::from()` methods.
```rust
fn main() {  
    let slice = "Charles Dickens";  
  
    let str = slice.to_string();  
    // or  
    let str = "Charles Dickens".to_string();  
    // or  
    let str = String::from("Charles Dickens");  
}
```

A String may also be converted to a string slice by adding the ampersand, `&` to a String, or by calling the `as_str()` method.
```rust
fn main() {  
    let slice = String::from("Charles Dickens");  
  
    let slice : (&str) = &str;  
    // or  
    let slice = str.as_str();  
}
```

Note that there is no real conversion happening here - we're just accessing the pointer to where the string lives in memory.

Several methods exist to concatenate Strings.  One is to use the `format!` macro.
```rust
fn main() {  
    let first_name = "Rasta";  
    let last_name = "Mouse";  
    let full_name = format!("{} {}", first_name, last_name);  
  
    println!("{}", full_name);  
}
```

If a String is mutable, you can call the `push_str()` method.
```rust
fn main() {  
    let mut name = String::from("Rasta");  
    name.push_str(" Mouse");  
  
    println!("{}", name)  
}
```

The `+` operator can also be used, but only to append a string slice to a String.
```rust
fn main() {  
    let first_name = String::from("Rasta");  
    let full_name = first_name + " Mouse";  
  
    println!("{}", full_name);  
}
```