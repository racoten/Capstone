
# 4. Collections

## Vectors

A vector is a simple "list" of values, who's data is stored on the heap.  Since the idea is to add and remove data from the vector, it should be declared as mutable.

Vectors can be created with `Vec::new()` or the `vec!` macro.

```rust
fn main() {  
    let mut vector : Vec<u8> = Vec::new();  
    // or  
    let mut vector : Vec<u8> = vec![];  
}
```

The vector has multiple functions that can be called to managed its values:

-   push - add new value to end of list.
-   pop - remove value.
-   iter - get an iteration to loop over.
-   remove - remove value.
-   insert - add value at given position.
-   clear - remove all values.
-   contains - returns a bool if the value exists or not.

Here's an example of creating an empty vector, pushing several values onto to, then iterating over them.

```rust
fn main() {  
    let mut vector : Vec<u8> = Vec::new();  
  
    vector.push(1);  
    vector.push(2);  
    vector.push(3);  
    vector.push(4);  
    vector.push(5);  
  
    for data in vector.iter() {  
        println!("{}", data);  
    }  
}
```

We could then insert a value at any given index.

```rust
fn main() {  
    let mut vector : Vec<u8> = Vec::new();  
  
    vector.push(1);  
    vector.push(2);  
    vector.push(3);  
    vector.push(4);  
    vector.push(5);  
  
    vector.insert(3, 99);  
  
    for data in vector.iter() {  
        println!("{}", data);  
    }  
}
```

This will insert the value 99 between the values 3 and 4.

The remove function, removes the data at the given index.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/b80/934/137/remove.png)

pop removes and returns the data from the bottom of the vector.  It returns an `Option<T>` which contains an enum indicating whether a value was found or not.  We'll cover enum's and `match` in a later module.

```rust
fn main() {  
    let mut vector : Vec<u8> = Vec::new();  
  
    vector.push(1);  
    vector.push(2);  
    vector.push(3);  
    vector.push(4);  
    vector.push(5);  
  
    vector.insert(3, 99);  
  
    let i = vector.pop();  
  
    match i {  
        Some(d) => println!("{}", d),  
        None => println!("Not found"),  
    }  
  
    for data in vector.iter() {  
        println!("{}", data);  
    }  
}
```

We can use contains to check whether a given value exists in the vector or not.

```rust
fn main() {  
    let mut vector : Vec<u8> = Vec::new();  
  
    vector.push(1);  
    vector.push(2);  
    vector.push(3);  
    vector.push(4);  
    vector.push(5);  
  
    vector.insert(3, 99);  
  
    let result = vector.contains(&3);  
    let result2 = vector.contains(&99);  
  
    println!("{}", result);  
    println!("{}", result2);  
}
```

## Maps

Rust has two types of map collection: the HashMap and BtreeMap.  Btree maps are typically used when you want to sort the keys.   If we create a HashMap, insert some values and then iterate over them, you can see that the results don't get printed in the same order in which they were added.

```rust
use std::collections::HashMap;  
  
fn main() {  
    let mut map: HashMap<u8, &str> = HashMap::new();  
  
    map.insert(1, "Number 1");  
    map.insert(2, "Number 2");  
    map.insert(3, "Number 3");  
    map.insert(4, "Number 4");  
    map.insert(5, "Number 5");  
  
    for kvp in map.iter() {  
        println!("Key: {}, Value: {}", kvp.0, kvp.1);  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/b85/46e/553/hashmap-output.png)

However, if we use a BTreeMap, then they are.

```rust
use std::collections::BTreeMap;  
  
fn main() {  
    let mut map: BTreeMap<u8, &str> = BTreeMap::new();  
  
    map.insert(1, "Number 1");  
    map.insert(2, "Number 2");  
    map.insert(3, "Number 3");  
    map.insert(4, "Number 4");  
    map.insert(5, "Number 5");  
  
    for kvp in map.iter() {  
        println!("Key: {}, Value: {}", kvp.0, kvp.1);  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/cf6/ae9/8b7/btree-map-output.png)

In most cases, this isn't particularly relevant as you would normally find data based on its known key.  To get a value by its key, use the `get()` function.  This also returns an `Option<T>`.

```rust
use std::collections::BTreeMap;  
  
fn main() {  
    let mut map: BTreeMap<u8, &str> = BTreeMap::new();  
  
    map.insert(1, "Number 1");  
    map.insert(2, "Number 2");  
    map.insert(3, "Number 3");  
    map.insert(4, "Number 4");  
    map.insert(5, "Number 5");  
  
    let value = map.get(&3);  
  
    match value {  
        Some (v) => println!("{}", v),  
        None => println!("Not found")  
    }  
}
```  

It's also important to note that Rust does not implement key collision checking.  If a key already exists in the map and you add it again, the old value will be overwritten.
```rust
use std::collections::HashMap;  
  
fn main() {  
    let mut map: HashMap<u8, &str> = HashMap::new();  
  
    map.insert(1, "Number 1");  
    map.insert(2, "Number 2");  
    map.insert(1, "New Number 1");  
  
    for kvp in map.iter() {  
        println!("Key: {}, Value: {}", kvp.0, kvp.1);  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/8a8/e56/32c/key-collision-output.png)

To check for a key collision prior to inserting a new key, use the `contains_key()` function.

```rust
use std::collections::HashMap;  
  
fn main() {  
    let mut map: HashMap<u8, &str> = HashMap::new();  
  
    map.insert(1, "Number 1");  
    map.insert(2, "Number 2");  
  
    if !map.contains_key(&1) {  
        map.insert(1, "New Number 1");  
    }  
  
    for kvp in map.iter() {  
        println!("Key: {}, Value: {}", kvp.0, kvp.1);  
    }  
}
```  

Here, we're using the bang, `!`, to assert if the map does not contain the key, `1`, and if it doesn't, insert the new pair.  Operators are covered in the next module.