# 15. Error Handling

## Panic

The Rust compiler does a fantastic job at of weeding out errors at compile-time.  Consider this example:

```rust
fn main() {  
    let array = [0; 5];  
    println!("{}", array[5]);  
}
```

Since array's are fixed size, the compiler knows that index 5 is out of bounds and will refuse to compile.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/bf6/266/afe/compile-error.png)

However, there are runtime bugs that can occur that can't be caught at compile time.  When Rust encounters a runtime error, it will cause a "panic".  Since a vector's size can change at runtime, the compiler doesn't know ahead of time if any given index will be valid.

```rust
fn main() {  
    let vector = vec![0; 5];  
    println!("{}", vector[5]);  
```

This code will build, but throws a panic (and crashes) when run.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/eaf/306/179/panic.png)

## Option

The vector (along with lots of other types in Rust) have a specific function called `get().`  In the case of a vector, it takes an index and returns an `Option<T>` enumeration.  This enum has two values:  `None` and `Some`.  `T` is a "generic", which means you can return any data type inside the enumeration.  We'll cover generics in a little more detail in the next module.

The `match` keyword can be used to execute code based on the content of the enum.

```rust
fn main() {  
    let vector = vec![1, 2, 3, 4, 5];  
    for i in 0..=5 {  
        let option = vector.get(i);  
        match option {  
            None => println!("No data found at index {}.", i),  
            Some (d) => println!("The data at {} is {}.", i, d)  
        }  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/c81/c57/bdc/get-output.png)

## Result

The `Result` enum builds on `Option` by allowing a function to return a reason for the failure.  Returning a reason is more useful because it allows the caller to handle the error in more specific ways, or to return a more accurate error message to the user.

The enum, `Result<T, E>` has two variants:  `Ok` and `Err`.

```rust
use std::fs;  
  
fn main() {  
    let result = fs::File::open("C:\\test.txt");  
    match result {  
        Ok(_) => println!("File opened"),  
        Err(e) => println!("Error opening file: {}", e)  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/820/40d/7e8/file-open-error.png

## Error Propagation

It's quite common to structure code in such a way that functions will call other functions.  This is generally because modular code is more usable and leads to less code repetition.  In this example, I have a program that opens a file and reads the content as a string.

`main` calls `read_file`, which calls `open_file`.

```rust
use std::fs::File;  
use std::io::{Error, Read};  
  
fn main() {  
    let result = read_file("C:\\test.txt");  
    match result {  
        Ok(c) => println!("{}", c),  
        Err(e) => println!("Error: {}", e)  
    }  
}  
  
fn read_file(path: &str) -> String {  
    let mut buf = String::new();  
    let mut file = open_file(path);  
    let _ = file.read_to_string(&mut buf);  
    buf  
}  
  
fn open_file(path: &str) -> File {  
    let result = File::open(path);  
    match result {  
        Ok() => {}  
        Err() => {}  
    }  
}
```

The issue we have is that open_file is expected to return a File, but we don't have a good way of handling an error inside the function itself.  What is it supposed to return?  How can it tell read_file that there was an error and how can read_file tell main?

This is where error propagation comes into play.  Here's the code and then I'll explain it:

```rust
use std::fs::File;  
use std::io::{Error, Read};  
  
fn main() {  
    let result = read_file("C:\\test.txt");  
    match result {  
        Ok(c) => println!("{}", c),  
        Err(e) => println!("Error: {}", e)  
    }  
}  
  
fn read_file(path: &str) -> Result<String, Error> {  
    let mut buf = String::new();  
    let mut file = open_file(path)?;  
    let _ = file.read_to_string(&mut buf);  
    Ok(buf)  
}  
  
fn open_file(path: &str) -> Result<File, Error> {  
    File::open(path);  
}
```

The first step is to refactor the read_file and open_file functions so that they return a Result<T,E>.  The Error enum I'm using is taken straight from the std::io library, so no extra work is required there.  For open_file, this allows us to completely eliminate the match and to just return the Result< File> directly.

Inside read_file, we append a question mark, `?` at the end of the call for open_file.  What this tells Rust is that if open_file returned an error, then send that error straight back to main and don't continue any further.  If open_file did not return an error, then continue to read the file.  read_file itself can then explicitly return an Ok after it has read the file.

This results in the caller, main, being the only function that needs to explicitly perform a match on the Result.

We can try this on a file that doesn't exist and one that does.

```rust
fn main() {  
    let result1 = read_file("C:\\test.txt");  
    match result1 {  
        Ok(c) => println!("{}", c),  
        Err(e) => println!("Error: {}", e)  
    }  
  
    let result2 = read_file("C:\\ok.txt");  
    match result2 {  
        Ok(c) => println!("{}", c),  
        Err(e) => println!("Error: {}", e)  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/58b/7cf/0e4/read-file.png)

## Debugging

A handy macro to be aware of is the `dbg!`, which is useful for some quick and dirty debugging.  It prints the value of an expression given to it.  For example, if we create and pass a vector to it, it will print each value.

```rust
fn main() {  
    let vector = vec![1, 2, 3, 4, 5];  
    dbg!(vector);  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/e62/e8d/3a5/dbg-vector-output.png)

Even more complicated object can be passed.  `fs::File::open` returns a `Result<File>`.  Quickly wrapping this in `dbg!` reveals the entire error behind the result.

```rust
use std::fs;  
  
fn main() {  
    let file_handle = fs::File::open("C:\\test.txt");  
    match file_handle {  
        Ok(_) => println!("File opened"),  
        Err(e) => { dbg!(e); }  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/f62/e49/4b3/dbg-file-open-output.png)