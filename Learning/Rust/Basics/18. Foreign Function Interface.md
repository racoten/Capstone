# 18. Foreign Function Interface

## Foreign Function Interface

The Foreign Function Interface (FFI) is the means by which Rust can access functionality within external C libraries.  The most common use case (particularly in the offensive security world) is to access the native Windows APIs (although since Rust is cross-platform it can be used with any C library).

Foreign functions are declared inside an `extern` block that has been annotated with the `link` attribute, where the `name` is the name of the library.  The following example shows how to import the `GetLastError` and `OpenProcess` APIs from `kernel32.dll`.  In each case, we define the function signature (i.e. the function name, any input parameters, and the return type).

```rust
#[link(name = "kernl32")]  
extern {  
    fn GetLastError() -> u32;  
    fn OpenProcess(dwDesiredAccess: u32, bInheritHandle: bool, dwProcessId: u32) -> *mut c_void;  
}
```

Functions imported through an extern block are automatically marked as unsafe.  Therefore, any call to a foreign function must be done from an unsafe context.  CLion also highlights unsafe functions with that red-ish background.

```rust
use std::ptr::null_mut;  
use std::ffi::c_void;  
  
#[link(name = "kernel32")]  
extern {  
    fn GetLastError() -> u32;  
    fn OpenProcess(dwDesiredAccess: u32, bInheritHandle: bool, dwProcessId: u32) -> *mut c_void;  
}  
  
fn main () {  
    let handle = unsafe {  
        OpenProcess(0xF01FF, false, 26768)  
    };  
  
    if handle == null_mut() {  
        println!("OpenProcess failed: {}", unsafe { GetLastError() });  
    } else {  
        println!("hProcess: {:x?}", handle);  
    }  
}
```

## Safe Wrappers

We can safe build wrappers around foreign functions, which also allow us to have more Rust-idiomatic functions at the same time.  For example, we could build a wrapper that returns a `Result` which can contain the correct error code upon failure.

```rust
use std::ptr::null_mut;  
use std::ffi::c_void;  
  
#[link(name = "kernel32")]  
extern {  
    fn GetLastError() -> u32;  
    fn OpenProcess(dwDesiredAccess: u32, bInheritHandle: bool, dwProcessId: u32) -> Result<*mut c_void, u32>;  
}  
  
fn main () {  
}  
  
fn open_process(desiredAccess: u32, inheritHandle: bool, processId: u32) -> Result<*mut c_void, u32> {  
    let handle = unsafe {  
        OpenProcess(desiredAccess, inheritHandle, processId)  
    };  
  
    if handle == null_mut() {  
        Err(unsafe { GetLastError() })  
    } else {  
        Ok(handle)  
    }  
}
```

This can then be called like any normal function and we can perform a match on the result instead of having an "if" check and a separate call to GetLastError as we had in the previous example.

```rust
fn main () {  
    let result = open_process(0xF01FF, false, 26768);  
    match result {  
        Ok(h) => { println!("hProcess: {:x?}", h)}  
        Err(e) => { println!("OpenProcess failed: {}", e)}  
    }  
}
```

You can also use these wrappers to convert Rust datatypes to native datatypes.  For example, several Windows APIs such as `LoadLibraryW` require an LPCWSTR, which is a pointer to a null-terminated 16-bit unicode string.  In Rust terms, that's a `*const u16`.

```rust
fn LoadLibraryW(lpLibFileName: *const u16) -> Result<*mut c_void, u32>;
```

Here we have a wrapper that takes a Rust string slice, converts it to the correct format, and ensures that it's null-terminated.

```rust
use std::ptr::null_mut;  
use std::ffi::c_void;  
  
#[link(name = "kernel32")]  
extern {  
    fn GetLastError() -> u32;  
    fn OpenProcess(dwDesiredAccess: u32, bInheritHandle: bool, dwProcessId: u32) -> Result<*mut c_void, u32>;  
    fn LoadLibraryW(lpLibFileName: *const u16) -> Result<*mut c_void, u32>;  
}  
  
fn main () {  
    let result = open_process(0xF01FF, false, 26768);  
    match result {  
        Ok(h) => { println!("hProcess: {:x?}", h)}  
        Err(e) => { println!("OpenProcess failed: {}", e)}  
    }  
}  
  
fn open_process(desiredAccess: u32, inheritHandle: bool, processId: u32) -> Result<*mut c_void, u32> {  
    let handle = unsafe {  
        OpenProcess(desiredAccess, inheritHandle, processId)  
    };  
  
    if handle == null_mut() {  
        Err(unsafe { GetLastError() })  
    } else {  
        Ok(handle)  
    }  
}  
  
fn load_library(file_name: &str) -> Result<*mut c_void, u32> {  
    // Convert to u16  
    let mut name = file_name.encode_utf16().collect::<Vec<u16>>();  
  
    // Ensure it ends in null byte  
    if *name.last().unwrap() != 0 {  
        name.push(0);  
    }  
  
    // Call API  
    let handle = unsafe { LoadLibraryW(name.as_ptr()) };  
  
    // Return  
    if handle == null_mut() {  
        Err(unsafe { GetLastError() })  
    } else {  
        Ok(handle)  
    }  
}
```