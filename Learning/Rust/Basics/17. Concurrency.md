# 17. Concurrency

## Concurrency

A single-core CPU has a single physical core that is designed to run at a given frequency (clock speed), with a single thread.  These CPUs are slow when handling multiple tasks, because each task has to wait for the previous one to finish before it can be dealt with.

CPU architecture began to drastically change in the early 2000's with the introduction of multi-core CPUs and in the mid-2000's, products such as the AMD Athlon 64 X2 and Intel Core 2 duo brought this to the regular desktop-computing space.  Multi-core CPUs contain multiple physical cores on the same die that are linked together, which allow for concurrent tasks to be handled in parallel.

As you can imagine, programming languages that were developed prior to multi-core CPUs were not optimised (or even able) to run concurrent tasks.  However, being a relatively young language, Rust was designed with concurrency in-mind.

There are some pit falls to be aware of when it comes to concurrency, which usually occur when multiple threads try to modify the same object at the same time; or when one thread locks access to an object, thus preventing another thread from accessing it.  Deadlocks can also occur if multiple threads are waiting a resource that they each have.

## Threads

A new thread can be created using `thread::spawn`, and the easiest way to execute code within the thread is to use a closure.

```rust
use std::thread;  
  
fn main() {  
    thread::spawn(|| {  
        println!("Hello from thread!");  
    });  
}
```

If you run this code, you won't actually see anything.  This is because the main program is exiting before the thread has a chance to run.  `thread::spawn` returns a `JoinHandle` which can be used to wait for the thread.  Be aware that this is a blocking action - code execution in main would not continue until the thread has finished.

After a thread has finished, we can check its Result.

```rust
use std::thread;

fn main() {  
    let handle = thread::spawn(|| {  
        println!("Hello from thread");  
    });  
    let result = handle.join();  
    match result {  
        Ok(_) => println!("Thread finished successfully"),  
        Err(_) => println!("Thread did not finish successfully")  
    }  
}
```

Our thread does not return a value, but it would be accessible in this enum if it did.  For example:

```rust
use std::thread;

fn main() {  
    let value = 20;  
    let handle = thread::spawn(move || -> i32 {  
        value * 2  
    });  
    let result = handle.join();  
    match result {  
        Ok(r) => println!("Result: {}", r),  
        Err(_) => println!("Thread did not finish successfully")  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/4c6/74d/eb1/move-result.png)

There is something else that's new here - the `move` keyword.  This forces the closure to take ownership of `value` so that it may be used within its scope.

## Channels

You can pass messages in and out of threads using channels.  A channel has both a sender and a receiver.

```rust
use std::sync::mpsc;  
  
fn main() {  
    let (s, r) = mpsc::channel();  
}
```

`mpsc` is short for "multi-producer, single-consumer".  It effectively means that multiple parties can send data into the channel, but only one party should be the receiver.  The channel can be deconstructed to allow easy access to the sender and receiver.

```rust
use std::sync::mpsc;  
use std::thread;  
  
fn main() {  
    let (s, r) = mpsc::channel();  
    let _ = thread::spawn(move || {  
        let _ = s.send("Hello from thread");  
    });  
}
```

We can then pass the sender into a new thread and have it write a message to the channel.  Outside of the thread, we can wait for messages on the receiver, and print it when it arrives.

```rust
use std::sync::mpsc;  
use std::thread;  
  
fn main() {  
    let (s, r) = mpsc::channel();  
    let _ = thread::spawn(move || {  
        let _ = s.send("Hello from thread");  
    });  
    match r.recv() {  
        Ok(m) => println!("{}", m),  
        Err(_) => {}  
    }  
}
```

![](https://files.cdn.thinkific.com/file_uploads/584845/images/6d8/b2b/da0/receive.png)

You could create multiple channels and multiple threads, pass the senders and receivers around accordingly, and multiple threads can talk to each other.