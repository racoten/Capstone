# 3. Variables

## Declaring

A variable is simply a "place to hold and use data".  A new variable can be declared with the `let` keyword, followed by a variable name, followed by a colon, followed by the data type, followed by an initial value.

For example, we can declare a new unsigned 32-bit integer as follows:

```rust
fn main() {  
    let my_integer : u32 = 0;  
}
```

This is the safest means of doing so, because there is no ambiguity over the data type.  However, you can allow the compiler to infer the data type based on your initial value.  For example:

```rust
fn main() {  
    let my_integer : i32 = 0;  
}
```

In this case, the compiler assumes the type `i32`, which is a signed (rather than unsigned) 32-bit integer.  CLion displays the inferred type inside the little grey box.  My personal rule of thumb is to allow the inference unless I notice that the data type is not the one that I want.

The rust compiler is very good at providing useful warnings when we try to build code that has various errors or inefficiencies.  If we declare a variable but never do anything with it, it will produce an "unused variable" warning.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/497/96d/21f/unused-variable.png)

This is a warning because it will allocate memory on the stack (which is wasteful since we're not using it) but is not fatal to the application.  There are instances where we may want to discard a variable.  For example, `some_function` returns a bool and in most cases, you would use that value to make some decision within your program.

```rust
fn main() {  
    let success = some_function();  
    if success {  
  
    }  
}  
  
fn some_function() {  
    // do stuff  
}
```

But for the sake of argument, let's say we don't need to.  Prepending the variable name with an underscore, `_`, tells the compiler to ignore the fact that it is unused and allows the code to compile without warning.  You can shorten this even further by dropping the variable name completely.

```rust
fn main() {  
    let _success = some_function();  
    let _ = some_function();  
}  
  
fn some_function() {  
    // do stuff  
}
```

We can also declare a variable as a constant, using the `const` keyword.

```rust
fn main() {  
    const MY_CONSTANT: i32 = 99;  
}
```

These are compile-time constants - they can only be read and never changed.

## Naming Conventions

Rust uses different text casing depending on the type of object being declared.  Here is a summary of the conventions:

| Object    | Casing               |
|-----------|----------------------|
| Variables | snake_case           |
| Functions | snake_case           |
| Constants | SCREAMING_SNAKE_CASE |
| Types     | PascalCase           |
| Traits    | PascalCase           |
| Enums     | PascalCase           |

We'll see many of these other types as we progress through the course.

## Casting

Casting is the process of converting one data type to another, which usually comes in two flavours:  implicit and explicit.  In a language like C#, you could declare an integer and implicitly cast it to a double:

![](https://files.cdn.thinkific.com/file_uploads/584845/images/fcd/2dd/a91/cs-implicit.png)

However, you cannot implicitly cast a double to an integer, so it must be explicitly cast:

  

![](https://files.cdn.thinkific.com/file_uploads/584845/images/8b1/9a3/e96/cs-explicit.png)

These two methods exist because explicit casting is typically more "dangerous" as it can result in a loss of data precision.  An integer is a whole number and cannot hold decimal places.  Converting 8 from an integer simply results in 8 as a double.  But converting 8.8 from a double results in 8 as an integer - we lose the .8 precision on the conversion.

Explicit casting exists because the compiler is forcing you to think about (and acknowledge) the conversion, rather than having it handled automatically for you.  However, Rust does not provide implicit casting on primitive data types, so everything must be explicitly cast.  This is done with the `as` keyword.

Consider the following:

```rust
fn main() {  
    let int8 : u8 = 255;  
    println!("{}", int8);  
  
    let int16 : u16 = int8 as u16;  
    println!("{}", int16);  
}
```

We first create an unsigned 8-bit integer (called `int8`) and assign the maximum possible value of 255.  
We then create an unsigned 16-bit integer (called `int16`) and assign its value by casting int8 as u16.

Both printline's show a value of 255.

Since the maximum value of a u16 is 65535, there is no "danger" in converting a u8 to a u16 because it cannot lose precision.  But we do if performed the other way around.

```rust
fn main() {  
    let int16 : u16 = 65535;  
    println!("{}", int16);  
  
    let int8 = int16 as u8;  
    println!("{}", int8);  
}
```

The first printline shows 65535, whilst the second shows 255.  We have lost data in the conversion from u16 to u8.  Casting is necessary in all sorts of places, such as mathematical operations.  Take this example:

```rust
fn main() {  
    let int16 : u16 = 65535;  
    let int8 : u8 = 255;  
    let result = int16 / int8;  
    println!("{}", result);  
}
```

This code will not compile because you cannot divide a u16 by a u8.  They both need to be the same data type.  We know that casting a u16 down to a u8 is probably a bad idea, and that the safer approach would be to cast the u8 up to a u16.

```rust
fn main() {  
    let int16 : u16 = 65535;  
    let int8 : u8 = 255;  
  
    let result = int16 / (int8 as u16);  
    println!("{}", result);  
}
```

This gives the result of 257.

You can also cast between other data types, such as integer to char (since a char is really just a numerical value anyway).

```rust
fn main() {  
    let int8 : u8 = 65;  
    let char8 = int8 as char;  
  
    println!("{}", char8);  
}
```  

This will print the character `A`.

As characters in Rust are 4 bytes, a u8 works fine.  However, you cannot convert something like a u16 to a char because the size is too large.  You also cannot convert nonsensically such as a string to a float.

## Mutability

Something that is "mutable" can be changed and something that is "immutable" cannot be changed.  Variables in Rust are immutable by default, which means you cannot change the value of a variable once assigned.

This code will not compile.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/1d8/eeb/47d/immutable.png)

A variable can be declared as mutable with the `mut` keyword.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/16d/9be/473/mutable.png)

Compound types (arrays and tuples) are also subject to mutability.  You cannot alter the value of an index without them being marked as mutable.

![](https://files.cdn.thinkific.com/file_uploads/584845/images/c11/f9f/2e5/mutable-array.png)